#!/usr/bin/env nextflow
// -*- mode: groovy; -*-
/*
vim: syntax=groovy
========================================================================================
                         nf-core/cleansumstats
========================================================================================
 nf-core/cleansumstats Analysis Pipeline.
 #### Homepage / Documentation
 https://github.com/nf-core/cleansumstats
----------------------------------------------------------------------------------------
*/

def helpMessage() {
    log.info nfcoreHeader()
    log.info"""

    Usage:

    The typical command for running the pipeline is as follows:

    nextflow run cleansumstats --input 'gwas_sumstats_meta_file.txt' -profile singularity

    Mandatory arguments:
      --input                       Path to metadata file in YAML format

    References:                     If not set here, it has to be specified in the configuration file 
      --dbsnp_38                    Path to dbsnp GRCh38 reference
      --dbsnp_38_37                 Path to dbsnp GRCh38 to GRCh37 map reference
      --dbsnp_37_38                 Path to dbsnp GRCh37 to GRCh38 map reference
      --dbsnp_36_38                 Path to dbsnp GRCh36 to GRCh38 map reference
      --dbsnp_35_38                 Path to dbsnp GRCh35 to GRCh38 map reference
      --dbsnp_RSID_38               Path to dbsnp RSID to GRCh38 map reference

    Options:
      --placeholderOption           Generates a meta file template, which is one of the required inputs to the cleansumstats pipeline

    Filtering:
      --beforeLiftoverFilter        A comma separated list ordered by filtering exclusion order including any of the following:
                                      duplicated_keys
                                    Example(default): --beforeLiftoverFilter duplicated_keys

      --afterLiftoverFilter         A comma separated list ordered by filtering exclusion order including any of the following:
                                      duplicated_chrpos_refalt_in_GRCh37
                                      duplicated_chrpos_refalt_in_GRCh38
                                      duplicated_chrpos_in_GRCh37
                                      duplicated_chrpos_in_GRCh38
                                      multiallelics_in_dbsnp
                                    Example(default): --afterLiftoverFilter duplicated_chrpos_refalt_in_GRCh37,duplicated_chrpos_refalt_in_GRCh38,duplicated_chrpos_in_GRCh37,duplicated_chrpos_in_GRCh38,multiallelics_in_dbsnp


      --afterAlleleCorrectionFilter A comma separated list ordered by filtering exclusion order including any of the following:
                                      duplicated_chrpos_in_GRCh37
                                    Example(default): --afterAlleleCorrectionFilter duplicated_chrpos_in_GRCh37

    Auxiliaries:
      --generateMetafile            Generates a meta file template, which is one of the required inputs to the cleansumstats pipeline

      --generateDbSNPreference      Generates a meta file template, which is one of the required inputs to the cleansumstats pipeline
      --hg38ToHg19chain             chain file used for liftover (required for --generateDbSNPreference)
      --hg19ToHg18chain             chain file used for liftover (required for --generateDbSNPreference)
      --hg19ToHg17chain             chain file used for liftover (required for --generateDbSNPreference)

    Other options:
      --outdir                      The output directory where the results will be saved
      --email                       Set this parameter to your e-mail address to get a summary e-mail with details of the run sent to you when the workflow exits
      --email_on_fail               Same as --email, except only send mail if the workflow is not successful
      --maxMultiqcEmailFileSize     Theshold size for MultiQC report to be attached in notification email. If file generated by pipeline exceeds the threshold, it will not be attached (Default: 25MB)
      -name                         Name for the pipeline run. If not specified, Nextflow will automatically generate a random mnemonic.

    Debug:
      --keepIntermediateFiles       Keeps intermediate files, useful for debugging

    AWSBatch options:
      --awsqueue                    The AWSBatch JobQueue that needs to be set when running on AWSBatch
      --awsregion                   The AWS Region for your AWS Batch job to run on
    """.stripIndent()

}

// Show help message
if (params.help) {
    helpMessage()
    exit 0
}

/*
 * SET UP CONFIGURATION VARIABLES
 */

// checker only
if(params.checkonly){
  doCompleteCleaningWorkflow = false
}else{
  doCompleteCleaningWorkflow = true
}

// check filter
beforeLiftoverFilter = params.beforeLiftoverFilter
afterLiftoverFilter = params.afterLiftoverFilter
afterAlleleCorrectionFilter = params.afterAlleleCorrectionFilter

// Set channels
if (params.generateDbSNPreference) {
  if (params.hg38ToHg19chain) { ch_hg38ToHg19chain = file(params.hg38ToHg19chain, checkIfExists: true) }
  if (params.hg19ToHg18chain) { ch_hg19ToHg18chain = file(params.hg19ToHg18chain, checkIfExists: true) }
  if (params.hg19ToHg17chain) { ch_hg19ToHg17chain = file(params.hg19ToHg17chain, checkIfExists: true) }

  if (params.dbsnp_38) { ch_dbsnp_38 = file(params.dbsnp_38) }
  if (params.dbsnp_38_37) { ch_dbsnp_38_37 = file(params.dbsnp_38_37) }
  if (params.dbsnp_37_38) { ch_dbsnp_37_38 = file(params.dbsnp_37_38) }
  if (params.dbsnp_36_38) { ch_dbsnp_36_38 = file(params.dbsnp_36_38) }
  if (params.dbsnp_35_38) { ch_dbsnp_35_38 = file(params.dbsnp_35_38) }
  if (params.dbsnp_RSID_38) { ch_dbsnp_RSID_38 = file(params.dbsnp_RSID_38) }
}else {
  if (params.dbsnp_38) { ch_dbsnp_38 = file(params.dbsnp_38, checkIfExists: true) }
  if (params.dbsnp_38_37) { ch_dbsnp_38_37 = file(params.dbsnp_38_37, checkIfExists: true) }
  if (params.dbsnp_37_38) { ch_dbsnp_37_38 = file(params.dbsnp_37_38, checkIfExists: true) }
  if (params.dbsnp_36_38) { ch_dbsnp_36_38 = file(params.dbsnp_36_38, checkIfExists: true) }
  if (params.dbsnp_35_38) { ch_dbsnp_35_38 = file(params.dbsnp_35_38, checkIfExists: true) }
  if (params.dbsnp_RSID_38) { ch_dbsnp_RSID_38 = file(params.dbsnp_RSID_38, checkIfExists: true) }
}

ch_regexp_lexicon = file("$baseDir/assets/map_regexp_and_adhocfunction.txt", checkIfExists: true)


if (params.kg1000AFGRCh38) { ch_kg1000AFGRCh38 = file(params.kg1000AFGRCh38, checkIfExists: true) }


// Stage config files
ch_multiqc_config = file(params.multiqc_config, checkIfExists: true)
ch_output_docs = file("$baseDir/docs/output.md", checkIfExists: true)

//example from nf-core how to use fasta
//params.fasta = params.genome ? params.genomes[ params.genome ].fasta ?: false : false
//if (params.fasta) { ch_fasta = file(params.fasta, checkIfExists: true) }

// Has the run name been specified by the user?
//  this has the bonus effect of catching both -name and --name
custom_runName = params.name
if (!(workflow.runName ==~ /[a-z]+_[a-z]+/)) {
  custom_runName = workflow.runName
}

if ( workflow.profile == 'awsbatch') {
  // AWSBatch sanity checking
  if (!params.awsqueue || !params.awsregion) exit 1, "Specify correct --awsqueue and --awsregion parameters on AWSBatch!"
  // Check outdir paths to be S3 buckets if running on AWSBatch
  // related: https://github.com/nextflow-io/nextflow/issues/813
  if (!params.outdir.startsWith('s3:')) exit 1, "Outdir not on S3 - specify S3 Bucket to run on AWSBatch!"
  // Prevent trace files to be stored on S3 since S3 does not support rolling files.
  if (workflow.tracedir.startsWith('s3:')) exit 1, "Specify a local tracedir or run without trace! S3 cannot be used for tracefiles."
}



// Header log info
log.info nfcoreHeader()
def summary = [:]
if (workflow.revision) summary['Pipeline Release'] = workflow.revision
summary['Run Name']         = custom_runName ?: workflow.runName
summary['Input']            = params.input
//if (params.dbsnp38) summary['dbSNP38'] = params.dbsnp38
//if (params.dbsnp37) summary['dbSNP37'] = params.dbsnp37
//if (params.dbsnp36) summary['dbSNP36'] = params.dbsnp36
//if (params.dbsnp35) summary['dbSNP35'] = params.dbsnp35
//if (params.dbsnpRSID) summary['dbsnpRSID'] = params.dbsnpRSID

summary['Max Resources']    = "$params.max_memory memory, $params.max_cpus cpus, $params.max_time time per job"
if (workflow.containerEngine) summary['Container'] = "$workflow.containerEngine - $workflow.container"
summary['Output dir']       = params.outdir
summary['Launch dir']       = workflow.launchDir
summary['Working dir']      = workflow.workDir
summary['Script dir']       = workflow.projectDir
summary['User']             = workflow.userName
if (workflow.profile == 'awsbatch') {
  summary['AWS Region']     = params.awsregion
  summary['AWS Queue']      = params.awsqueue
}
summary['Config Profile'] = workflow.profile
if (params.config_profile_description) summary['Config Description'] = params.config_profile_description
if (params.config_profile_contact)     summary['Config Contact']     = params.config_profile_contact
if (params.config_profile_url)         summary['Config URL']         = params.config_profile_url
if (params.email || params.email_on_fail) {
  summary['E-mail Address']    = params.email
  summary['E-mail on failure'] = params.email_on_fail
  summary['MultiQC maxsize']   = params.maxMultiqcEmailFileSize
}
log.info summary.collect { k,v -> "${k.padRight(18)}: $v" }.join("\n")
log.info "-\033[2m--------------------------------------------------\033[0m-"

// Check the hostnames against configured profiles
checkHostname()

def create_workflow_summary(summary) {
    def yaml_file = workDir.resolve('workflow_summary_mqc.yaml')
    yaml_file.text  = """
    id: 'nf-core-cleansumstats-summary'
    description: " - this information is collected when the pipeline is started."
    section_name: 'nf-core/cleansumstats Workflow Summary'
    section_href: 'https://github.com/nf-core/cleansumstats'
    plot_type: 'html'
    data: |
        <dl class=\"dl-horizontal\">
${summary.collect { k,v -> "            <dt>$k</dt><dd><samp>${v ?: '<span style=\"color:#999999;\">N/A</a>'}</samp></dd>" }.join("\n")}
        </dl>
    """.stripIndent()

   return yaml_file
}


process get_software_versions {
    publishDir "${params.outdir}/pipeline_info", mode: 'copy', overwrite: true, pattern: '*.csv'

    output:
    file 'software_versions_mqc.yaml' into software_versions_yaml
    file "software_versions.csv" into ch_software_versions


    script:
    """
    echo $workflow.manifest.version > v_pipeline.txt
    echo $workflow.nextflow.version > v_nextflow.txt
    #sstools-version > v_sumstattools.txt
    scrape_software_versions.py &> software_versions_mqc.yaml
    """
}


if (params.generateMetafile){
  ch_metatemplate = file("${baseDir}/assets/meta_data_readMe_v4.txt")
  ch_sumstat_file = Channel
                   .fromPath(params.input, type: 'file')
                   .map { file -> tuple(file.baseName, file) }

  process create_meta_data_template {

      publishDir "${params.outdir}", mode: 'copy', overwrite: false, enabled: params.dev

      input:
      tuple basefilename, sfilename from ch_sumstat_file

      output:
      file("${basefilename}.meta") into ch_metafile_template_out

      script:
      """
      cat ${ch_metatemplate} > ${basefilename}.meta
      """
  }
}else if(params.generateDbSNPreference){

  // ##Download from web
  // #wget ftp://ftp.ncbi.nlm.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/VCF/All_20180418.vcf.*

  ch_file = Channel
    .fromPath(params.input, type: 'file')
    .map { file -> tuple(file.baseName, file) }

  dbsnpsplits = 10

  process dbsnp_reference_convert_and_split {

      cpus 2

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple basefilename, dbsnpvcf from ch_file

      output:
      file("chunk_*") into ch_dbsnp_split
      file("dbsnp_GRCh38")

      script:
      """
      ##Download from web
      #wget ftp://ftp.ncbi.nlm.nih.gov/snp/organisms/human_9606_b151_GRCh38p7/VCF/All_20180418.vcf.*
      module load tools
      module load pigz/2.3.4

      #reformat
      pigz --decompress --stdout --processes 2 ${dbsnpvcf} | grep -v "#" > dbsnp_GRCh38

      #split into dbsnpsplit number of unix split files
      split -dn ${dbsnpsplits} dbsnp_GRCh38 chunk_

      """
  }

  ch_dbsnp_split
    .flatten()
    .map { file -> tuple(file.baseName, file) }
    .set { ch_dbsnp_split2 }

  process dbsnp_reference_reformat {

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple cid, dbsnp_chunk from ch_dbsnp_split2

      output:
      tuple cid, file("${cid}_All_20180418_GRCh38.bed") into ch_dbsnp_preformatted

      script:
      """
      awk '{print "chr"\$1, \$2, \$2,  \$1":"\$2, \$3, \$4, \$5}' ${dbsnp_chunk} > ${cid}_All_20180418_GRCh38.bed
      """
  }

  process dbsnp_reference_rm_indels {

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple cid, dbsnp_chunk from ch_dbsnp_preformatted

      output:
      tuple cid, file("${cid}_All_20180418_GRCh38.bed.noindel") into ch_dbsnp_rmd_indels

      script:
      """
      # Remove all insertions or deletions
      # this will eliminate some rsids, both the ones with multiple rsids for the exact same snp, but also the ones with ref and alt switched.
      awk ' \$7 !~ /,/{if(length(\$6)!=1 || length(\$7)!=1 || \$6=="." || \$7=="."){print \$0 > "rm_indels"}else{print \$0}}; \$7 ~ /,/{if(\$7 ~ /\\w\\w/){print \$0 > "rm_indels2"}else{print \$0}} ' ${dbsnp_chunk} > ${cid}_All_20180418_GRCh38.bed.noindel
      """
  }

  ch_dbsnp_rmd_indels.into { ch_dbsnp_rmd_indels1; ch_dbsnp_rmd_indels2 }

  process dbsnp_reference_report_number_of_biallelic_multiallelics {

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple cid, dbsnp_chunk from ch_dbsnp_rmd_indels1

      output:
      tuple cid, file("*") into ch_dbsnp_report_biallelic_mult_alleles

      script:
      """
      ## investigate the amount of single base multi allelics left (without filtering them out from the main workflow)
      awk ' \$7 ~ /,/{print \$0} ' ${dbsnp_chunk} > ${cid}_biallelic_multiallelics
      """
  }

  process dbsnp_reference_rm_dup_positions_GRCh38 {

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple cid, dbsnp_chunk from ch_dbsnp_rmd_indels2

      output:
      tuple cid, file("${cid}_All_20180418_GRCh38.bed.noindel.sorted.nodup") into ch_dbsnp_rmd_dup_positions_GRCh38
      file("${cid}_All_20180418_GRCh38.bed.noindel.sorted")

      script:
      """
      # Remove all duplicated positions GRCh38
      # this will eliminate some rsids, both the ones with multiple rsids for the exact same snp, but also the ones with ref and alt swithed.
      LC_ALL=C sort -k 4,4 --parallel 8 ${dbsnp_chunk} > ${cid}_All_20180418_GRCh38.bed.noindel.sorted
      awk 'BEGIN{r0="initrowhere"} {var=\$4; if(r0!=var){print \$0}else{print \$0 > "removed_duplicated_rows_GRCh38"}; r0=var}' ${cid}_All_20180418_GRCh38.bed.noindel.sorted > ${cid}_All_20180418_GRCh38.bed.noindel.sorted.nodup

      """
  }

  ch_dbsnp_rmd_dup_positions_GRCh38.into { ch_dbsnp_rmd_dup_positions_GRCh38_1; ch_dbsnp_rmd_dup_positions_GRCh38_2; ch_dbsnp_rmd_dup_positions_GRCh38_3 }

  process dbsnp_reference_liftover_GRCh37 {

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple cid, dbsnp_chunk from ch_dbsnp_rmd_dup_positions_GRCh38_1

      output:
      tuple cid, file("${cid}_dbsnp_chunk_GRCh37_GRCh38") into ch_dbsnp_lifted_to_GRCh37
      file("${cid}_dbsnp_chunk_GRCh37")

      script:
      """
      #for some reason I have to copy the chain file to the wd for it to be found
      cp ${ch_hg38ToHg19chain} chain2.gz

      # Map to GRCh37
      CrossMap.py bed chain2.gz ${dbsnp_chunk} ${cid}_dbsnp_chunk_GRCh37
      awk '{tmp=\$1; sub(/[cC][hH][rR]/, "", tmp); print \$1, \$2, \$3, tmp":"\$2, \$4, \$5, \$6, \$7}' ${cid}_dbsnp_chunk_GRCh37 > ${cid}_dbsnp_chunk_GRCh37_GRCh38
      """
  }

  process dbsnp_reference_rm_dup_positions_GRCh37 {

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple cid, dbsnp_chunk from ch_dbsnp_lifted_to_GRCh37

      output:
      tuple cid, file("All_20180418_liftcoord_GRCh37_GRCh38.bed.sorted.nodup") into ch_dbsnp_rmd_dup_positions_GRCh37
      file("All_20180418_liftcoord_GRCh37_GRCh38.bed.sorted")

      script:
      """
      # Remove all duplicated positions GRCh37 (as some positions might have become duplicates after the liftover)
      LC_ALL=C sort -k 4,4 --parallel 4 ${dbsnp_chunk} > All_20180418_liftcoord_GRCh37_GRCh38.bed.sorted
      awk 'BEGIN{r0="initrowhere"} {var=\$4; if(r0!=var){print \$0}else{print \$0 > "removed_duplicated_rows_GRCh37"}; r0=var}' All_20180418_liftcoord_GRCh37_GRCh38.bed.sorted > All_20180418_liftcoord_GRCh37_GRCh38.bed.sorted.nodup
      """
  }

  process dbsnp_reference_rm_liftover_remaining_ambigous_GRCh37 {

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple cid, dbsnp_chunk from ch_dbsnp_rmd_dup_positions_GRCh37

      output:
      tuple cid, file("${cid}_All_20180418_liftcoord_GRCh37_GRCh38.bed.sorted.nodup.chromclean") into ch_dbsnp_rmd_ambig_GRCh37_liftovers
      file("${cid}_all_chr_types_GRCh37")

      script:
      """
      #To get a list of all chromosomes types
      awk '{gsub(":.*","",\$1); print \$1}' ${dbsnp_chunk} | awk '{ seen[\$1] += 1 } END { for (i in seen) print seen[i],i }' > ${cid}_all_chr_types_GRCh37

      #remove non standard chromosome names (seems like they include a "_" in the name)
      awk '{tmp=\$1; gsub(":.*","",\$1); if(\$1 !~ /_/ ){print tmp,\$2,\$3,\$4,\$5,\$6,\$7,\$8}}' ${dbsnp_chunk} > ${cid}_All_20180418_liftcoord_GRCh37_GRCh38.bed.sorted.nodup.chromclean
      """
  }

  ch_dbsnp_rmd_ambig_GRCh37_liftovers.into { ch_dbsnp_rmd_ambig_GRCh37_liftovers1; ch_dbsnp_rmd_ambig_GRCh37_liftovers2; ch_dbsnp_rmd_ambig_GRCh37_liftovers3 }

  process dbsnp_reference_liftover_GRCh36 {

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple cid, dbsnp_chunk from ch_dbsnp_rmd_ambig_GRCh37_liftovers1

      output:
      tuple cid, file("${cid}_All_20180418_liftcoord_GRCh36.bed"), build into ch_dbsnp_lifted_to_GRCh36

      script:
      build = "36"
      """
      #for some reason I have to copy the chain file to the wd for it to be found
      cp ${ch_hg19ToHg18chain} chain2.gz

      #liftover
      CrossMap.py bed chain2.gz ${dbsnp_chunk} ${cid}_All_20180418_liftcoord_GRCh36.bed
      """
  }

  process dbsnp_reference_liftover_GRCh35 {

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple cid, dbsnp_chunk from ch_dbsnp_rmd_ambig_GRCh37_liftovers2

      output:
      tuple cid, file("${cid}_All_20180418_liftcoord_GRCh35.bed"), build into ch_dbsnp_lifted_to_GRCh35

      script:
      build = "35"
      """
      #for some reason I have to copy the chain file to the wd for it to be found
      cp ${ch_hg19ToHg17chain} chain2.gz

      #liftover
      CrossMap.py bed chain2.gz ${dbsnp_chunk} ${cid}_All_20180418_liftcoord_GRCh35.bed
      """
  }

  ch_dbsnp_lifted_to_GRCh35
    .mix(ch_dbsnp_lifted_to_GRCh36)
    .set{ ch_dbsnp_lifted_to_GRCh3x }

  process dbsnp_reference_rm_duplicates_GRCh36_GRCh35 {

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple cid, dbsnp_chunk, build from ch_dbsnp_lifted_to_GRCh3x

      output:
      tuple build, cid, file("${cid}_All_20180418_GRCh${build}_GRCh38.bed.sorted.nodup") into ch_dbsnp_rmd_dup_positions_GRCh3x
      file("${cid}_All_20180418_GRCh${build}_GRCh38.bed.sorted")

      script:
      """
      # Remove all duplicated positions GRCh36 (as some positions might have become duplicates after the liftover)
      LC_ALL=C sort -k 4,4 --parallel 4 ${dbsnp_chunk} > ${cid}_All_20180418_GRCh${build}_GRCh38.bed.sorted
      awk 'BEGIN{r0="initrowhere"} {var=\$4; if(r0!=var){print \$0}else{print \$0 > "removed_duplicated_rows_GRCh${build}"}; r0=var}' ${cid}_All_20180418_GRCh${build}_GRCh38.bed.sorted > ${cid}_All_20180418_GRCh${build}_GRCh38.bed.sorted.nodup
      """
  }

  process dbsnp_reference_rm_liftover_remaining_ambigous_GRCh36_GRCh35 {

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple build, cid, dbsnp_chunk from ch_dbsnp_rmd_dup_positions_GRCh3x

      output:
      tuple build, cid, file("${cid}_All_20180418_liftcoord_GRCh${build}_GRCh38.bed.sorted.nodup.chromclean") into ch_dbsnp_rmd_ambig_positions_GRCh3x
      file("${cid}_all_chr_types_GRCh${build}")

      script:
      """
      #To get a list of all chromosomes types
      awk '{gsub(":.*","",\$1); print \$1}' ${dbsnp_chunk} | awk '{ seen[\$1] += 1 } END { for (i in seen) print seen[i],i }' > ${cid}_all_chr_types_GRCh${build}

      #remove non standard chromosome names (seems like they include a "_" in the name)
      awk '{tmp=\$1; gsub(":.*","",\$1); if(\$1 !~ /_/ ){print tmp,\$2,\$3,\$4,\$5,\$6,\$7,\$8}}' ${dbsnp_chunk} > ${cid}_All_20180418_liftcoord_GRCh${build}_GRCh38.bed.sorted.nodup.chromclean
      """
  }

  process dbsnp_reference_make_rsid_version_from_GRCh38 {

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple cid, dbsnp_chunk from ch_dbsnp_rmd_dup_positions_GRCh38_2

      output:
      file("${cid}_All_20180418_RSID_GRCh38.bed") into ch_dbsnp_rsid_to_GRCh38

      script:
      """
      # Make version sorted on RSID to get correct coordinates
      awk '{print \$5, \$4, \$6, \$7}' ${dbsnp_chunk} > ${cid}_All_20180418_RSID_GRCh38.bed
      """
  }

  process dbsnp_reference_merge_and_put_files_in_reference_library_RSID {

      publishDir "${params.libdirdbsnp}", mode: 'copy', overwrite: false, enabled: params.dev

      input:
      file dbsnp_chunks from ch_dbsnp_rsid_to_GRCh38.collect()

      output:
      file("${ch_dbsnp_RSID_38.baseName}.bed")

      script:
      """
      # Concatenate
      for chunk in ${dbsnp_chunks}
      do
        cat \${chunk} >> All_20180418_RSID_GRCh38.map
      done

      # Sort
      LC_ALL=C sort -k 1,1 --parallel 8 All_20180418_RSID_GRCh38.map > "${ch_dbsnp_RSID_38.baseName}.bed"

      """
  }

//
// collect and STORE dbsnp files in reference library
//

  process dbsnp_reference_merge_and_put_files_in_reference_library_GRCh38 {

      publishDir "${params.libdirdbsnp}", mode: 'copy', overwrite: false, enabled: params.dev

      input:
      file dbsnp_chunks from ch_dbsnp_rmd_dup_positions_GRCh38_3.collect()

      output:
      file("${ch_dbsnp_38.baseName}.bed")

      script:
      """
      # Concatenate
      for chunk in ${dbsnp_chunks}
      do
        cat \${chunk} >> All_20180418_RSID_GRCh38.map
      done

      # Sort
      awk '{print \$4,\$5,\$6,\$7}' All_20180418_RSID_GRCh38.map | LC_ALL=C sort -k 1,1 --parallel 8 > "${ch_dbsnp_38.baseName}.bed"

      """
  }


  process dbsnp_reference_merge_and_put_files_in_reference_library_GRCh38_GRCh37 {

      publishDir "${params.libdirdbsnp}", mode: 'copy', overwrite: false, enabled: params.dev
      publishDir "${params.outdir}", mode: 'symlink', overwrite: true, pattern: '*.map', enabled: params.dev

      input:
      file dbsnp_chunks from ch_dbsnp_rmd_ambig_GRCh37_liftovers3.collect()

      output:
      file("${ch_dbsnp_38_37.baseName}.bed")
      file("${ch_dbsnp_37_38.baseName}.bed")
      file("*map")

      script:
      """
      # Concatenate
      for chunk in ${dbsnp_chunks}
      do
        cat \${chunk} >> All_20180418_GRCh38_GRCh37_tmp.map
      done

      awk '{print \$4, \$5, \$6, \$7, \$8}' All_20180418_GRCh38_GRCh37_tmp.map > All_20180418_GRCh37_GRCh38.map
      awk '{print \$5, \$4, \$6, \$7, \$8}' All_20180418_GRCh38_GRCh37_tmp.map > All_20180418_GRCh38_GRCh37.map

      # Sort
      LC_ALL=C sort -k 1,1 --parallel 8 All_20180418_GRCh38_GRCh37.map > "${ch_dbsnp_38_37.baseName}.bed"

      # Sort
      LC_ALL=C sort -k 1,1 --parallel 8 All_20180418_GRCh37_GRCh38.map > "${ch_dbsnp_37_38.baseName}.bed"

      """
  }

  ch_dbsnp_rmd_ambig_positions_GRCh3x_grouped = ch_dbsnp_rmd_ambig_positions_GRCh3x.groupTuple(by:0)

  process dbsnp_reference_merge_and_put_files_in_reference_library_GRCh3x_GRCh38 {

      publishDir "${params.outdir}/intermediates", mode: 'symlink', overwrite: true, pattern: '*.map', enabled: params.dev
      publishDir "${params.libdirdbsnp}", mode: 'copy', overwrite: false, pattern: '*.bed', enabled: params.dev

      input:
      tuple build, cid, file(dbsnp_chunks) from ch_dbsnp_rmd_ambig_positions_GRCh3x_grouped

      output:
      file("*.bed")
      file("*.map")

      script:
      """
      # Concatenate
      for chunk in ${dbsnp_chunks}
      do
        cat \${chunk} >> All_20180418_GRCh${build}_GRCh38.map
      done

      # Sort
      if [ "${build}" == "36" ]; then
        awk '{tmp=\$1; sub(/[cC][hH][rR]/, "", tmp); print tmp":"\$2, \$5, \$6, \$7, \$8}' All_20180418_GRCh36_GRCh38.map | LC_ALL=C sort -k 1,1 --parallel 8 > "${ch_dbsnp_36_38.baseName}.bed"
      else
        awk '{tmp=\$1; sub(/[cC][hH][rR]/, "", tmp); print tmp":"\$2, \$5, \$6, \$7, \$8}' All_20180418_GRCh35_GRCh38.map | LC_ALL=C sort -k 1,1 --parallel 8 > "${ch_dbsnp_35_38.baseName}.bed"
      fi

      """
  }
}else if(params.generate1KgAfSNPreference){

  // ##Download from web
  // ##Download readme describing the new mapping directly to GRCh38
  // ##wget http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data_collections/1000_genomes_project/release/20190312_biallelic_SNV_and_INDEL/20190312_biallelic_SNV_and_INDEL_README.txt
  // ##
  // ###then download the datasets from this website portal
  // ##wget http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data_collections/1000_genomes_project/release/20190312_biallelic_SNV_and_INDEL/ALL.wgs.shapeit2_integrated_snvindels_v2a.GRCh38.27022019.sites.vcf.gz
  // ##wget http://ftp.1000genomes.ebi.ac.uk/vol1/ftp/data_collections/1000_genomes_project/release/20190312_biallelic_SNV_and_INDEL/ALL.wgs.shapeit2_integrated_snvindels_v2a.GRCh38.27022019.sites.vcf.gz.tbi
  // ##

  ch_file = Channel
    .fromPath(params.input, type: 'file')
    .map { file -> tuple(file.baseName, file) }

  process extract_frequency_data {

      publishDir "${params.outdir}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple basefilename, af1kgvcf from ch_file

      output:
      tuple basefilename, file("1kg_af_ref") into ch_1kg_af_ref

      script:
      """
      module load tools
      module load bcftools/1.11
      gendb_1kaf_extract_freq_data.sh ${af1kgvcf} > 1kg_af_ref

      """
  }

  // As 1KG by default shows alternative allele frequency, we flip to follow our default on showing effect allele frequency, which in our system will be the reference allele frequency.
  process flip_frequency_data {

      publishDir "${params.outdir}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple basefilename, ref1kg from ch_1kg_af_ref

      output:
      tuple basefilename, file("1kg_af_ref.flipped") into ch_1kg_af_ref_tosort

      script:
      """
      #sort 1kg af reference on position
      awk '{print \$1, \$2, \$3, 1-\$4, 1-\$5, 1-\$6, 1-\$7, 1-\$8}' ${ref1kg} > 1kg_af_ref.flipped
      """
  }

  process sort_frequency_data {

      cpus 4

      publishDir "${params.outdir}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple basefilename, ref1kg from ch_1kg_af_ref_tosort

      output:
      tuple basefilename, file("1kg_af_ref.sorted") into ch_1kg_af_ref_sorted

      script:
      """
      #sort 1kg af reference on position
      LC_ALL=C sort -k 1,1 --parallel 4 ${ref1kg} > 1kg_af_ref.sorted
      """
  }

  process join_frequency_data_on_dbsnp_reference {

      publishDir "${params.outdir}", mode: 'symlink', overwrite: true

      input:
      tuple basefilename, ref1kgsorted from ch_1kg_af_ref_sorted

      output:
      tuple basefilename, file("1kg_af_ref.sorted.joined")

      script:
      """
      #join the two datasets
      LC_ALL=C join -1 1 -2 1 ${ref1kgsorted} ${ch_dbsnp_38} > 1kg_af_ref.sorted.joined

      """
  }
      //#check for not agreeing ref alleles and alt alleles
      // awk '{if($2!=$10){print $0}}' 1kg_af_ref.sorted.joined | head
      // awk '{if($3!=$11){print $0}}' 1kg_af_ref.sorted.joined | head

}else {



  //use metafile filename as datasetID through the pipeline
  ch_mfile_checkX = Channel
                  .fromPath(params.input, type: 'file')
                  .map { file -> tuple(file.baseName, file) }

  ch_mfile_checkX.into { ch_mfile_user_1; ch_mfile_user_2; ch_mfile_user_3 }

  process check_filter_params {
      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple datasetID, mfile from ch_mfile_user_3

      output:
      file("params_check_filtername_afterLiftoverFilter.log")
      tuple datasetID, mfile into ch_mfile_user_3x

      script:
      """
      check_filter_names.sh ${afterLiftoverFilter} ${baseDir}/assets/allowed_names_afterLiftoverFilter.txt params_check_filtername_afterLiftoverFilter.log

      """
  }


  process calculate_checksum_on_metafile_user {
      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple datasetID, mfile from ch_mfile_user_3x

      output:
      tuple datasetID, env(usermetachecksum) into ch_usermeta_checksum
      file("usermetachecksum.txt")

      script:
      """
      b3sum ${mfile} | awk '{print \$1}' > usermetachecksum.txt
      usermetachecksum="\$(cat usermetachecksum.txt)"
      """
  }


  process make_meta_file_unix_friendly {
      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple datasetID, mfile from ch_mfile_user_1

      output:
      tuple datasetID, mfile, file("mfile_unix_safe") into ch_mfile_unix_safe
      file("mfile_unix_safe2")

      script:
      """
      cat ${mfile} > mfile_sent_in

      # Clean meta file from windows return characters
      awk '{ sub("\\r\$", ""); print }' ${mfile} > mfile_unix_safe2

      # Remove obviously misplaced whitespaces (i.e., any whitespace before =, and leading whitespace directly after =)
      # Remove trailing whitespaces (i.e., any whitespace between the newline character and the last non whitespace character of the string)
      awk '\$1 !~ "#" && \$1 !~ "^ *\$"{split(\$0,out,"="); gsub(/ */, "", out[1]); sub(/ */, "", out[2]); sub(/ *\$/, "", out[2]); print out[1]"="out[2]} \$1 ~ "#" || \$1 ~ "^ *\$"{print \$0}' mfile_unix_safe2  > mfile_unix_safe
      """
  }


  process check_most_crucial_paths_exists {

      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple datasetID, mfile, mfile_unix_safe from ch_mfile_unix_safe

      output:
      tuple datasetID, mfile_unix_safe, env(spath) into ch_mfile_check_format
      tuple datasetID, env(spath) into ch_input_sfile
      tuple datasetID, env(rpath) into ch_input_readme
      tuple datasetID, env(pmid) into ch_pmid
      tuple datasetID, env(pmid), env(pdfpath), file("${datasetID}_pdf_suppfiles.txt") into ch_input_pdf_stuff
      file("mfile_sent_in")

      script:
      """
      metaDir="\$(dirname ${mfile})"
      cat ${mfile} > mfile_sent_in

      # Check if the datasetID folder is already present, if so just increment a number to get the new outname
      #  this is because a metafile can have the same name as another even though the content might be different.

      # Check if field for variable exists and if the file specified exists
      check_meta_file_references.sh "path_sumStats" $mfile_unix_safe \$metaDir > spath.txt
      spath="\$(cat spath.txt)"
      check_meta_file_references.sh "path_readMe" $mfile_unix_safe \$metaDir > rpath.txt
      rpath="\$(cat rpath.txt)"
      check_meta_file_references.sh "path_pdf" $mfile_unix_safe \$metaDir > pdfpath.txt
      pdfpath="\$(cat pdfpath.txt)"
      check_meta_file_references.sh "path_supplementary" $mfile_unix_safe \${metaDir} > ${datasetID}_pdf_suppfiles.txt

      Px="\$(grep "^study_PMID=" $mfile_unix_safe)"
      pmid="\$(echo "\${Px#*=}")"

      # Check library if this has been processed before
      # TODO after the script producing the 00inventory.txt has been created

      """
  }

  ch_input_sfile.into { ch_input_sfile1; ch_input_sfile2 }

  process calculate_checksum_on_raw_sumstat {
      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple datasetID, sfile from ch_input_sfile1

      output:
      tuple datasetID, env(rawsumstatchecksum) into ch_rawsumstat_checksumX

      script:
      """
      rawsumstatchecksum="\$(b3sum ${sfile} | awk '{print \$1}')"
      """
  }
  ch_rawsumstat_checksumX.into { ch_rawsumstat_checksum1; ch_rawsumstat_checksum2 }

  process check_mfile_format {

      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple datasetID, mfile, sfilePath from ch_mfile_check_format

      output:
      tuple datasetID, mfile, sfilePath into ch_mfile_check_libID
      file("${datasetID}_header")
      tuple datasetID, file("*.log")

      script:
      """
      # Make complete metafile check
      echo "\$(head -n 1 < <(zcat ${sfilePath}))" > ${datasetID}_header
      check_meta_data_format.sh ${mfile} ${datasetID}_header ${datasetID}_mfile_format.log

      """

  }


  process check_and_force_basic_sumstat_format {

      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple datasetID, mfile, sfilePath from ch_mfile_check_libID

      output:
      tuple datasetID, mfile into ch_mfile_ok
      tuple datasetID, file("${datasetID}_sfile") into ch_sfile_ok
      tuple datasetID, file("desc_force_tab_sep_BA.txt") into ch_desc_prep_force_tab_sep_BA
      file("${datasetID}_sfile_1000")
      file("${datasetID}_sfile_1000_formatted")
      file("*.log")

      script:
      """
      # Sumstat file check on first 1000 lines
      echo "\$(head -n 1000 < <(zcat ${sfilePath}))" | gzip -c > ${datasetID}_sfile_1000
      check_and_format_sfile.sh ${datasetID}_sfile_1000 ${datasetID}_sfile_1000_formatted ${datasetID}_sfile_1000_format.log

      # Make second sumstat file check on all lines
      check_and_format_sfile.sh ${sfilePath} ${datasetID}_sfile ${datasetID}_sfile_format.log
      #check_and_format_sfile.sh ${datasetID}_sfile_1000 ${datasetID}_sfile ${datasetID}_sfile_format.log

      #process before and after stats (the -1 is to remove the header count)
      rowsBefore="\$(zcat ${sfilePath} | wc -l | awk '{print \$1-1}')"
      rowsAfter="\$(wc -l ${datasetID}_sfile | awk '{print \$1-1}')"
      echo -e "\$rowsBefore\t\$rowsAfter\tForce tab separation" > desc_force_tab_sep_BA.txt
      """
  }

if (doCompleteCleaningWorkflow){

    process add_sorted_index_sumstat {

        input:
        tuple datasetID, sfile from ch_sfile_ok

        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        output:
        tuple datasetID, file("prep_sfile_added_rowindex") into ch_sfile_on_stream
        tuple datasetID, file("desc_add_sorted_rowindex_BA.txt") into ch_desc_prep_add_sorted_rowindex_BA

        script:
        """
        cat $sfile | sstools-raw add-index | LC_ALL=C sort -k 1 - > prep_sfile_added_rowindex

        #process before and after stats (the -1 is to remove the header count)
        rowsBefore="\$(wc -l $sfile | awk '{print \$1-1}')"
        rowsAfter="\$(wc -l prep_sfile_added_rowindex | awk '{print \$1-1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tAdd sorted rowindex, which maps back to the unfiltered file" > desc_add_sorted_rowindex_BA.txt
        """
    }

    ch_mfile_ok.into { ch_mfile_ok1; ch_mfile_ok2; ch_mfile_ok3; ch_mfile_ok4; ch_mfile_ok5; ch_mfile_ok6; ch_mfile_rerun_7; ch_mfile_ok_8}

   // ch_mfile_ok7
   //  .combine(ch_sfile_on_stream0, by: 0)
   //  .set { ch_sfile_on_stream00 }


    ch_sfile_on_stream.into { ch_sfile_on_stream1; ch_sfile_on_stream2; ch_sfile_on_stream4; ch_sfile_on_stream5; ch_before_liftover }
    ch_mfile_and_stream=ch_mfile_ok1.join(ch_sfile_on_stream1)
    ch_mfile_and_stream.into { ch_check_gb; ch_liftover; ch_liftover1; ch_liftover2; ch_stats_inference }

    process does_chrpos_exist {

        input:
        tuple datasetID, mfile from ch_mfile_ok6

        output:
        tuple datasetID, env(CHRPOSexists),env(SNPexists),env(pointsToDifferent) into ch_present_markers

        script:
        """
        decide_SNP_CHRPOS_path.sh $mfile > decisiontable
        #make environment variables of the declarations in this file
        source decisiontable
        """
    }

   ch_present_markersX=ch_liftover1.combine(ch_present_markers, by: 0)
   ch_present_markersX.into { ch_present_markers_1; ch_present_markers_2 }

    process check_if_chrpos_col_is_different_from_snp_and_assign_dID2 {

        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, mfile, sfile, chrposExists, snpExists, pointsToDifferentCols from ch_present_markers_2

        output:
        tuple datasetID, env(dID2), mfile, file("prep_chrpos"), snpExists into ch_chrpos_init

        script:
        """
        dID2="liftover_branch_chrpos"

        if [ "${chrposExists}" == "true" ] && [ "${pointsToDifferentCols}" == "true" ]
        then
          cp ${sfile} prep_chrpos
        else
          head -n1 ${sfile} > prep_chrpos
        fi

        """
    }


    // LIFTOVER BRANCH 1

    process prep_dbsnp_mapping_for_rsid {

        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, mfile, sfile, chrposExists, snpExists, pointsToDifferentCols from ch_present_markers_1

        output:
        tuple datasetID, mfile, file("gb_lift"), snpExists into ch_liftover_33
        tuple datasetID, env(dID2), mfile, file("gb_lift2"), snpExists into ch_liftover_snpchrpos
        //tuple datasetID, file("desc_prepare_format_for_dbsnp_mapping_BA.txt") into ch_desc_prep_for_dbsnp_mapping_BA_chrpos_rsid
        //tuple datasetID, file("desc_sex_chrom_formatting_BA.txt") into ch_desc_sex_chrom_formatting_BA_1

        script:
        """
        dID2="liftover_branch_markername_chrpos"

        echo -e "0\tRSID" > gb_lift
        echo -e "0\tMarkername" > gb_lift2

        if [ "${snpExists}" == "true" ]
        then
          Sx="\$(grep "^col_SNP=" $mfile)"
          colSNP="\$(echo "\${Sx#*=}")"
          #select columns and then split in one rs file and one snpchrpos file
          cat ${sfile} | sstools-utils ad-hoc-do -k "0|\${colSNP}" -n"0,RSID" | awk -vFS="\t" -vOFS="\t" '{print \$2,\$1}' | awk -vFS="\t" -vOFS="\t" 'NR>1{if(\$1 ~ /^rs.*/){ print \$0 }else{ print \$0 >> "gb_lift2" }}' >> gb_lift
        fi
        #use the empty header data to continue with, which should make this branch quick

        #process before and after stats
        rowsBefore="\$(wc -l ${sfile} | awk '{print \$1-1}')"
        rowsAfter="\$(wc -l gb_lift | awk '{print \$1-1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tPrepare file for mapping to dbsnp by sorting the mapping index" > desc_prepare_format_for_dbsnp_mapping_BA.txt
        """
    }

    process remove_duplicated_rsid_before_liftover_rsid_version {

        publishDir "${params.outdir}/${datasetID}/intermediates/liftover_branch_markername_rsid", mode: 'symlink', overwrite: true, enabled: params.dev
        publishDir "${params.outdir}/${datasetID}/intermediates/liftover_branch_markername_rsid/removed_lines", mode: 'symlink', overwrite: true, pattern: 'removed_*', enabled: params.dev

        input:
        tuple datasetID, mfile, rsidprep, snpExists from ch_liftover_33

        output:
        tuple datasetID, mfile, file("gb_unique_rows_sorted"), snpExists into ch_liftover_3333
        //tuple datasetID, file("desc_removed_duplicated_rows") into ch_removed_rows_before_liftover_rsids
        tuple datasetID, file("removed_duplicated_rows") into ch_removed_rows_before_liftover_ix_rsids
        file("removed_*")
        file("beforeLiftoverFiltering_executionorder")

        script:
        """
        if [ "${snpExists}" == "true" ]
        then
          filter_before_liftover.sh $rsidprep ${beforeLiftoverFilter}
        else
          #make empty file (has no header)
          touch gb_unique_rows_sorted
        fi

        """
    }


    process liftover_to_GRCh38_and_map_to_dbsnp_rsid_version {

        publishDir "${params.outdir}/${datasetID}/intermediates/liftover_branch_markername_rsid", mode: 'symlink', overwrite: true, enabled: params.dev
        publishDir "${params.outdir}/${datasetID}/intermediates/liftover_branch_markername_rsid/removed_lines", mode: 'symlink', overwrite: true, pattern: 'removed_*', enabled: params.dev

        input:
        tuple datasetID, mfile, fsorted, snpExists from ch_liftover_3333

        output:
        tuple datasetID, mfile, file("gb_lifted_and_mapped_to_GRCh38") into ch_liftover_rsid
        //tuple datasetID, file("desc_liftover_to_GRCh38_and_map_to_dbsnp_BA") into ch_desc_liftover_to_GRCh38_and_map_to_dbsnp_BA_rsid
        //tuple datasetID, file("${datasetID}.stats") into ch_stats_genome_build_rsid
        tuple datasetID, file("removed_not_matching_during_liftover_ix") into ch_not_matching_during_liftover_rsid
        file("removed_*")

        script:
        """

        if [ "${snpExists}" == "true" ]
        then
          #in gb_lifted_and_mapped_to_GRCh38, the order will be
          #GRCh38, GRCh37, rowIndex, RSID, REF, ALT
          #chr:pos | inx | rsid | a1 | a2 | chr:pos2 (if available)
          LC_ALL=C join -1 1 -2 1 ${fsorted} ${ch_dbsnp_RSID_38} | awk -vFS="[[:space:]]" -vOFS="\t" '{print \$3,\$2,\$1,\$4,\$5}'  > gb_lifted_and_mapped_to_GRCh38

          # Lines not possible to map
          LC_ALL=C join -v 1 -1 1 -2 3 ${fsorted} gb_lifted_and_mapped_to_GRCh38 > removed_not_matching_during_liftover
          awk -vOFS="\t" '{print \$2,"not_matching_during_liftover"}' removed_not_matching_during_liftover > removed_not_matching_during_liftover_ix
        else
          #make empty file (has no header)
          touch gb_lifted_and_mapped_to_GRCh38
          touch removed_not_matching_during_liftover_ix
        fi


        # Process before and after stats
        rowsBefore="\$(wc -l ${fsorted} | awk '{print \$1-1}')"
        rowsAfter="\$(wc -l gb_lifted_and_mapped_to_GRCh38 | awk '{print \$1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tLiftover to GRCh38 and simultaneously map to dbsnp" > desc_liftover_to_GRCh38_and_map_to_dbsnp_BA

        """
    }


    // LIFTOVER BRANCH 2 - chrpos mapping

    //mix the snpchrpos (from markername column) with chrpos (from own columns)
    ch_chrpos_init
      .mix(ch_liftover_snpchrpos)
      .set{ ch_liftover_snpchrpos_chrpos_mixed }

    process reformat_X_Y_XY_and_MT_and_remove_noninterpretables {

        publishDir "${params.outdir}/${datasetID}/intermediates/${dID2}", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, dID2, mfile, sfile, chrposexist from ch_liftover_snpchrpos_chrpos_mixed

        output:
        tuple datasetID, dID2, mfile, file("prep_sfile_forced_sex_chromosome_format") into ch_chromosome_fixed
        path("new_chr_sex_format")
        path("new_chr_sex_format2")
        path("new_chr_sex_format3")
        //tuple datasetID, file("desc_sex_chrom_formatting_BA.txt") into ch_desc_sex_chrom_formatting_BA_2
        tuple datasetID, env(rowsAfter) into ch_rowsAfter_number_of_lines

        script:
        """
        Cx="\$(grep "^col_CHR=" $mfile)"
        colCHR="\$(echo "\${Cx#*=}")"

        #check number of rows in file
        nrrows="\$(wc -l ${sfile})"

        #if only header row, then do nothing
        if [ "\${nrrows}" == "1" ]
        then
          #will just forward the header, as the header should be the only thing present if this is true
          cat ${sfile}  > prep_sfile_forced_sex_chromosome_format
        else
          #make
          cat $sfile | sstools-utils ad-hoc-do -k "0|funx_force_sex_chromosomes_format(\${colCHR})" -n"0,\${colCHR}" > new_chr_sex_format

          #remove sex formats of unknown origin
          colCHR=\$(map_to_adhoc_function.sh ${ch_regexp_lexicon} ${mfile} ${sfile} "chr")
          echo "\${colCHR}" > gb_ad-hoc-do_funx_CHR_sex_chrom_filter
          cat new_chr_sex_format | sstools-utils ad-hoc-do -k "0|\${colCHR}" -n"0,CHR" | awk -vFS="\t" -vOFS="\t" 'BEGIN{getline; print \$0}; {if(\$2 > 0 && \$2 < 27){ print \$1, \$2 }}' > new_chr_sex_format2
          #use the index to remove everything no part of chr numers 1-26 but keep original format
          LC_ALL=C join -t "\$(printf '\t')" -o 1.1 1.2 -1 1 -2 1 new_chr_sex_format new_chr_sex_format2 > new_chr_sex_format3

          #replace (if bp or allele info is in the same column it will be kept, as the function above only replaces the chr info part)
          head -n1 $sfile > header
          to_keep_from_join="\$(awk -vFS="\t" -vobj=\${colCHR} '{for (i=1; i<=NF; i++){if(obj==\$i){print "2."2}else{print "1."i}}}' header)"
          LC_ALL=C join -t "\$(printf '\t')" -o \${to_keep_from_join} -1 1 -2 1 $sfile new_chr_sex_format3 > prep_sfile_forced_sex_chromosome_format
        fi

        #process before and after stats (the -1 is to remove the header count)
        rowsBefore="\$(wc -l $sfile | awk '{print \$1-1}')"
        rowsAfter="\$(wc -l prep_sfile_forced_sex_chromosome_format | awk '{print \$1-1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tforced sex chromosomes and mitochondria chr annotation to the numbers 23-26" > desc_sex_chrom_formatting_BA.txt
        """
    }

ch_chromosome_fixed.into {ch_chromosome_fixed1; ch_chromosome_fixed2}

    whichbuild = ['GRCh35', 'GRCh36', 'GRCh37', 'GRCh38']

    process genome_build_stats {

        publishDir "${params.outdir}/${datasetID}/intermediates/${dID2}", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, dID2, mfile, sfile from ch_chromosome_fixed1
        each build from whichbuild

        output:
        tuple datasetID, dID2, file("${datasetID}*.res") into ch_genome_build_stats
        file("gb_*")

        script:
        """

        colCHR=\$(map_to_adhoc_function.sh ${ch_regexp_lexicon} ${mfile} ${sfile} "chr")
        colPOS=\$(map_to_adhoc_function.sh ${ch_regexp_lexicon} ${mfile} ${sfile} "bp")
        echo "\${colCHR}" > gb_ad-hoc-do_funx_CHR_${build}
        echo "\${colPOS}" > gb_ad-hoc-do_funx_POS_${build}

        #check number of rows in file
        nrrows="\$(wc -l ${sfile})"
        #if only header row, then do nothing
        if [ "\${nrrows}" == "1" ]
        then
          #I here choose to set number of mapped to 0, as nothing has been mapped.
          echo -e "0\t${build}" > ${datasetID}.${build}.res
        else
          cat ${sfile} | sstools-utils ad-hoc-do -k "0|\${colCHR}|\${colPOS}" -n"0,CHR,BP" > gb_extract_and_format_chr_and_pos_to_detect_build_${build}
          awk -vFS="\t" -vOFS="\t" '{print \$2":"\$3,\$1}' gb_extract_and_format_chr_and_pos_to_detect_build_${build} > gb_ready_to_join_to_detect_build_${build}
          LC_ALL=C sort -k1,1 gb_ready_to_join_to_detect_build_${build} > gb_ready_to_join_to_detect_build_sorted_${build}
          format_chrpos_for_dbsnp.sh ${build} gb_ready_to_join_to_detect_build_sorted_${build} ${ch_dbsnp_35_38} ${ch_dbsnp_36_38} ${ch_dbsnp_37_38} ${ch_dbsnp_38} > ${build}.map
          sort -u -k1,1 ${build}.map | wc -l | awk -vOFS="\t" -vbuild=${build} '{print \$1,build}' > ${datasetID}.${build}.res
        fi

        """
    }


    ch_genome_build_stats_grouped = ch_genome_build_stats.groupTuple(by:[0,1],size:4)

    process infer_genome_build {

        publishDir "${params.outdir}/${datasetID}/intermediates/${dID2}", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, dID2, file(ujoins) from ch_genome_build_stats_grouped


        output:
        tuple datasetID, dID2, env(GRChmax) into ch_known_genome_build
        tuple datasetID, dID2, file("${datasetID}.stats") into ch_stats_genome_build_chrpos
        tuple datasetID, dID2, file("GRChOther"), env(GRChmaxVal) into ch_build_stats_for_failsafe
        file("GRChmax")

        script:
        """
        for gbuild in ${ujoins}
        do
            cat \$gbuild >> ${datasetID}.stats
        done
        GRChmax="\$(cat ${datasetID}.stats | sort -nr -k1,1 | head -n1 | awk '{print \$2}')"
        GRChmaxVal="\$(cat ${datasetID}.stats | sort -nr -k1,1 | head -n1 | awk '{print \$1}')"

        cat ${datasetID}.stats | sort -nr -k1,1 | tail -n+2 > GRChOther
        echo \${GRChmax} > GRChmax

        """
    }


    ch_rowsAfter_number_of_lines
      .combine(ch_build_stats_for_failsafe, by: 0)
      .set{ ch_failsafe }

    process genome_build_mapping_warning {

      publishDir "${params.outdir}/${datasetID}/intermediates/${dID2}", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, tot, dID2, buildstat, grmax from ch_failsafe

        output:
        tuple datasetID, file("warningsFile") into ch_warning_liftover

        script:
        """
        #make empty warningsfile
        touch warningsFile

        #if tot is not 0
        if [ "${tot}" == "0" ]; then
          :
        else
          #check if anything should be added to the warningsfile
          warnings_liftover_percentage.sh ${grmax} ${tot} ${buildstat} ${dID2} >> warningsFile
        fi
        """
    }


//  ch_known_genome_build.view()
//  ch_liftover.view()

// Add respective sfile part
    ch_liftover_2=ch_known_genome_build.combine(ch_chromosome_fixed2, by: [0,1])

//  ch_liftover_2.view()

    process prep_dbsnp_mapping_by_sorting_chrpos_version {
        publishDir "${params.outdir}/${datasetID}/intermediates/${dID2}", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, dID2, gbmax, mfile, sfile from ch_liftover_2

        output:
        tuple datasetID, dID2, mfile, file("gb_lift"), gbmax into ch_liftover_3
        //tuple datasetID, file("desc_prepare_format_for_dbsnp_mapping_BA.txt") into ch_desc_prep_for_dbsnp_mapping_BA_chrpos

        script:
        """

        colCHR=\$(map_to_adhoc_function.sh ${ch_regexp_lexicon} ${mfile} ${sfile} "chr")
        colPOS=\$(map_to_adhoc_function.sh ${ch_regexp_lexicon} ${mfile} ${sfile} "bp")

        cat ${sfile} | sstools-utils ad-hoc-do -k "0|\${colCHR}|\${colPOS}" -n"0,CHR,BP" | awk -vFS="\t" -vOFS="\t" '{print \$2":"\$3,\$1}' > gb_lift
        #LC_ALL=C sort -k1,1 gb_lift > gb_lift_sorted

        #process before and after stats
        rowsBefore="\$(wc -l ${sfile} | awk '{print \$1-1}')"
        rowsAfter="\$(wc -l gb_lift | awk '{print \$1-1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tPrepare file for mapping to dbsnp by sorting the mapping index" > desc_prepare_format_for_dbsnp_mapping_BA.txt
        """

    }


    process remove_duplicated_chr_position_before_liftover {

        publishDir "${params.outdir}/${datasetID}/intermediates/${dID2}", mode: 'symlink', overwrite: true, enabled: params.dev
        publishDir "${params.outdir}/${datasetID}/intermediates/${dID2}/removed_lines", mode: 'symlink', overwrite: true, pattern: 'removed_*', enabled: params.dev

        input:
        tuple datasetID, dID2, mfile, chrposprep, gbmax from ch_liftover_3

        output:
        tuple datasetID, dID2, mfile, file("gb_unique_rows_sorted"), gbmax into ch_liftover_333
        //tuple datasetID, file("desc_removed_duplicated_rows") into ch_removed_rows_before_liftover_chrpos
        tuple datasetID, file("removed_duplicated_rows") into ch_removed_rows_before_liftover_ix_chrpos
        file("removed_*")
        file("beforeLiftoverFiltering_executionorder")

        script:
        """
        filter_before_liftover.sh $chrposprep ${beforeLiftoverFilter}

        """
    }



  process liftover_to_GRCh38_and_map_to_dbsnp_chrpos_version {

        publishDir "${params.outdir}/${datasetID}/intermediates/${dID2}", mode: 'symlink', overwrite: true, enabled: params.dev
        publishDir "${params.outdir}/${datasetID}/intermediates/${dID2}/removed_lines", mode: 'symlink', overwrite: true, pattern: 'removed_*', enabled: params.dev

        input:
        tuple datasetID, dID2, mfile, fsorted, gbmax from ch_liftover_333

        output:
        tuple datasetID, dID2, mfile, file("gb_lifted_and_mapped_to_GRCh38") into ch_liftover_44
        //tuple datasetID, file("desc_liftover_to_GRCh38_and_map_to_dbsnp_BA") into ch_desc_liftover_to_GRCh38_and_map_to_dbsnp_BA_chrpos
        tuple datasetID, file("removed_not_matching_during_liftover_ix") into ch_not_matching_during_liftover_chrpos
        file("removed_*")
        file("lifted_middle_step*")

        script:
        """

        #check number of rows in file
        nrrows="\$(wc -l ${fsorted})"
        #if only header row, then do nothing
        if [ "\${nrrows}" == "1" ]
        then
          #I here choose to set number of mapped to 0, as nothing has been mapped. This file does not have a header.
          touch gb_lifted_and_mapped_to_GRCh38

          #nothing should be in here
          touch lifted_middle_step

          #as the this subset of the data is empty, we have to make this file empty as well
          # even though it would have been more logical to fill it with all lines from the original sfile
          touch removed_not_matching_during_liftover
          touch removed_not_matching_during_liftover_ix
        else

          #in gb_lifted_and_mapped_to_GRCh37_and_GRCh38, the order will be
          #GRCh38, GRCh37, rowIndex, RSID, REF, ALT
          #chr:pos | inx | rsid | a1 | a2 | chr:pos2 (if available)
          if [ "${gbmax}" == "GRCh38" ] ; then
            LC_ALL=C join -1 1 -2 1 $fsorted ${ch_dbsnp_38} > lifted_middle_step
            awk -vFS="[[:space:]]" -vOFS="\t" '{print \$1,\$2,\$3,\$4,\$5}' lifted_middle_step > gb_lifted_and_mapped_to_GRCh38
          elif [ "${gbmax}" == "GRCh37" ] ; then
            LC_ALL=C join -1 1 -2 1 $fsorted ${ch_dbsnp_37_38} > lifted_middle_step
            awk -vFS="[[:space:]]" -vOFS="\t" '{print \$3,\$2,\$4,\$5,\$6}' lifted_middle_step > gb_lifted_and_mapped_to_GRCh38
          elif [ "${gbmax}" == "GRCh36" ] ; then
            LC_ALL=C join -1 1 -2 1 $fsorted ${ch_dbsnp_36_38} > lifted_middle_step
            awk -vFS="[[:space:]]" -vOFS="\t" '{print \$3,\$2,\$4,\$5,\$6}' lifted_middle_step > gb_lifted_and_mapped_to_GRCh38
          elif [ "${gbmax}" == "GRCh35" ] ; then
            LC_ALL=C join -1 1 -2 1 $fsorted ${ch_dbsnp_35_38} > lifted_middle_step
            awk -vFS="[[:space:]]" -vOFS="\t" '{print \$3,\$2,\$4,\$5,\$6}' lifted_middle_step > gb_lifted_and_mapped_to_GRCh38
          else
            echo "${gbmax} is none of the available builds 35, 36, 37 or 38"
          fi


          # Lines not possible to map
          LC_ALL=C join -v 1 -1 1 -2 1 ${fsorted} lifted_middle_step > removed_not_matching_during_liftover
          awk -vOFS="\t" '{print \$2,"not_matching_during_liftover"}' removed_not_matching_during_liftover > removed_not_matching_during_liftover_ix

        fi

        #process before and after stats
        rowsBefore="\$(wc -l ${fsorted} | awk '{print \$1-1}')"
        rowsAfter="\$(wc -l gb_lifted_and_mapped_to_GRCh38 | awk '{print \$1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tLiftover to GRCh38 and simultaneously map to dbsnp" > desc_liftover_to_GRCh38_and_map_to_dbsnp_BA
        """
    }

//   ch_liftover_44.view()

    //branch the chrpos and snpchrpos channels
    ch_chrpos_snp_filter=ch_liftover_44.branch { key, value, mfile, liftedGRCh38 ->
                    liftover_branch_markername_chrpos: value == "liftover_branch_markername_chrpos"
                    liftover_branch_chrpos: value == "liftover_branch_chrpos"
                    }
    ch_chrpos=ch_chrpos_snp_filter.liftover_branch_chrpos
    ch_snpchrpos=ch_chrpos_snp_filter.liftover_branch_markername_chrpos

//  ch_chrpos.view()

    //join the chrpos and snpchrpos channels
    ch_chrpos
      .join(ch_snpchrpos, by: 0)
      .join(ch_liftover_rsid, by: 0)
      .join(ch_before_liftover, by: 0)
      .set{ ch_combined_chrpos_snpchrpos_rsid }

    //ch_combined_chrpos_snpchrpos_rsid.view()

process select_chrpos_over_snpchrpos {

      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple datasetID, dID2, mfile, liftedGRCh38, dID2SNP, mfileSNP, liftedGRCh38SNP, mfileRSID, liftedGRCh38RSID, beforeLiftover from ch_combined_chrpos_snpchrpos_rsid

      output:
      tuple datasetID, mfile, file("combined_set_from_the_three_liftover_branches_sorted") into ch_liftover_final
      tuple datasetID, file("beforeAndAfterFile") into ch_desc_combined_set_after_liftover
      tuple datasetID, file("removed_not_possible_to_lift_over_for_combined_set_ix") into ch_removed_not_possible_to_lift_over_for_combined_set_ix
      file("liftedGRCh38_sorted")
      file("rsid_to_add")
      file("snpchrpos_unique")
      file("snpchrpos_to_add")
      file("tmp_test")

      script:
      """
      cp ${beforeLiftover} tmp_test
      #any row inx from rsid or snpchrpos not in chrpos
      LC_ALL=C sort -k2,2 ${liftedGRCh38} > liftedGRCh38_sorted
      LC_ALL=C sort -k2,2 ${liftedGRCh38RSID} > liftedGRCh38RSID_sorted
      LC_ALL=C sort -k2,2 ${liftedGRCh38SNP} > liftedGRCh38SNP_sorted
      LC_ALL=C join -t "\$(printf '\t')" -v 1 -1 2 -2 2 -o 1.1 1.2 1.3 1.4 1.5 liftedGRCh38RSID_sorted liftedGRCh38_sorted > rsid_to_add
      LC_ALL=C join -t "\$(printf '\t')" -v 1 -1 2 -2 2 -o 1.1 1.2 1.3 1.4 1.5 liftedGRCh38SNP_sorted liftedGRCh38_sorted > snpchrpos_unique
      LC_ALL=C join -t "\$(printf '\t')" -v 1 -1 2 -2 2 -o 1.1 1.2 1.3 1.4 1.5 snpchrpos_unique rsid_to_add > snpchrpos_to_add

      #if so, then add it to the output
      cat liftedGRCh38_sorted rsid_to_add snpchrpos_to_add > combined_set_from_the_three_liftover_branches
      LC_ALL=C sort -k2,2 combined_set_from_the_three_liftover_branches > combined_set_from_the_three_liftover_branches_sorted

      # Lines not possible to map for the combined set
      LC_ALL=C join -t "\$(printf '\t')" -v 1 -1 2 -2 1 -o 2.1 combined_set_from_the_three_liftover_branches_sorted ${beforeLiftover} > removed_not_possible_to_lift_over_for_combined_set
      awk -vOFS="\t" '{print \$1,"not_available_for_any_of_the_three_liftover_branches"}' removed_not_possible_to_lift_over_for_combined_set > removed_not_possible_to_lift_over_for_combined_set_ix

      #process before and after stats
      rowsBefore="\$(wc -l ${beforeLiftover} | awk '{print \$1-1}')"
      rowsAfter="\$(wc -l combined_set_from_the_three_liftover_branches_sorted | awk '{print \$1}')"
      echo -e "\$rowsBefore\t\$rowsAfter\tAfter creating the combined set from the three liftover paths" > beforeAndAfterFile
      """
}

//ch_liftover_final.view()

    //branch the stats_genome_build
    ch_stats_genome_build_filter=ch_stats_genome_build_chrpos.branch { key, value, file ->
                    liftover_branch_markername_chrpos: value == "liftover_branch_markername_chrpos"
                    liftover_branch_chrpos: value == "liftover_branch_chrpos"
                    }
    ch_stats_chrpos_gb=ch_stats_genome_build_filter.liftover_branch_chrpos
    ch_stats_snpchrpos_gb=ch_stats_genome_build_filter.liftover_branch_markername_chrpos

    //combine the chrpos and snpchrpos channels for genome build
    ch_stats_chrpos_gb
      .join(ch_stats_snpchrpos_gb, by: 0)
      .map { key, val, file, val2, file2 -> tuple(key, file, file2) }
      .set{ ch_gb_stats_combined }

//ch_gb_stats_combined.view()


    process remove_duplicated_chr_position_allele_rows {

        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev
        publishDir "${params.outdir}/${datasetID}/intermediates/removed_lines", mode: 'symlink', overwrite: true, pattern: 'removed_*', enabled: params.dev

        input:
        tuple datasetID, mfile, liftedandmapped from ch_liftover_final

        output:
        tuple datasetID, mfile, file("gb_unique_rows_sorted") into ch_liftover_4
        tuple datasetID, file("desc_removed_duplicated_rows") into ch_desc_removed_duplicates_after_liftover
        tuple datasetID, file("removed_duplicated_rows") into ch_removed_duplicates_after_liftover_ix
        file("removed_*")
        file("afterLiftoverFiltering_executionorder")

        script:
        """
        filter_after_liftover.sh $liftedandmapped ${afterLiftoverFilter}

        """
    }


    process split_off_GRCh38 {
        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, mfile, liftedandmapped from ch_liftover_4

        output:
        //tuple datasetID, val("GRCh37"), mfile, file("gb_lifted_GRCh37") into ch_mapped_GRCh37
        tuple datasetID, val("GRCh38"), mfile, file("gb_lifted_GRCh38") into ch_mapped_GRCh38
        //tuple datasetID, file("desc_keep_only_GRCh37_version_BA.txt") into ch_desc_keep_only_GRCh37_version_BA
        tuple datasetID, file("desc_keep_a_GRCh38_reference_BA.txt") into ch_desc_keep_a_GRCh38_reference_BA

        script:
        """
        #prepare GRCh38 for downstream analysis
        awk -vFS="[[:space:]]" -vOFS="\t" '{print \$2,\$1,\$3,\$4,\$5}' $liftedandmapped > gb_lifted_GRCh38

        #split off GRCh37 to use only for coordinate reference
        #awk -vFS="[[:space:]]" -vOFS="\t" '{print \$3,\$1,\$4,\$5,\$6}' $liftedandmapped > gb_lifted_GRCh37


        #process before and after stats
        #rowsBefore="\$(wc -l $liftedandmapped | awk '{print \$1}')"
        #rowsAfter="\$(wc -l gb_lifted_GRCh37 | awk '{print \$1}')"
        #echo -e "\$rowsBefore\t\$rowsAfter\tKeep only GRCh37 coordinates alleleinfo, which will be the file subjected to further cleaning" > desc_keep_only_GRCh37_version_BA.txt


        #process before and after stats
        rowsBefore="\$(wc -l $liftedandmapped | awk '{print \$1}')"
        rowsAfter="\$(wc -l gb_lifted_GRCh38 | awk '{print \$1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tSplit off a version of GRCh38 as coordinate reference" > desc_keep_a_GRCh38_reference_BA.txt
        """
    }


    process split_multiallelics_and_resort_index {

        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, build, mfile, liftgrs from ch_mapped_GRCh38

        output:
        tuple datasetID, build, mfile, file("gb_multialleles_splittorows") into ch_allele_correction
        tuple datasetID, file("desc_split_multi_allelics_and_sort_on_rowindex_BA.txt") into ch_desc_split_multi_allelics_and_sort_on_rowindex_BA
        file("gb_splitted_multiallelics")

        script:
        """
        split_multiallelics_to_rows.sh $liftgrs > gb_splitted_multiallelics
        echo -e "0\tCHRPOS\tRSID\tA1\tA2" > gb_multialleles_splittorows
        LC_ALL=C sort -k1,1 gb_splitted_multiallelics >> gb_multialleles_splittorows

        #process before and after stats (rows is -1 because of header)
        rowsBefore="\$(wc -l $liftgrs | awk '{print \$1}')"
        rowsAfter="\$(wc -l gb_multialleles_splittorows | awk '{print \$1-1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tSplit multi-allelics to multiple rows and sort on original rowindex " > desc_split_multi_allelics_and_sort_on_rowindex_BA.txt

        """
    }

    ch_allele_correction_combine=ch_allele_correction.combine(ch_sfile_on_stream2, by: 0)
    ch_allele_correction_combine.into{ ch_allele_correction_combine1; ch_allele_correction_combine2 }

    process does_exist_A2 {

        input:
        tuple datasetID, mfile from ch_mfile_ok2

        output:
        tuple datasetID, env(A2exists) into ch_present_A2

        script:
        """
        A2exists=\$(doesA2exist.sh $mfile)
        """
    }

    //Create filter for when A2 exists or not
    ch_present_A2_br=ch_present_A2.branch { key, value ->
                    A2exists: value == "true"
                    A2missing: value == "false"
                    }

    //split the channels based on filter
    ch_present_A2_br2=ch_present_A2_br.A2exists
    ch_present_A2_br3=ch_present_A2_br.A2missing

    //combine each channel with the matching datasetID
    ch_A2_exists=ch_allele_correction_combine1.combine(ch_present_A2_br2, by: 0)
    ch_A2_missing=ch_allele_correction_combine2.combine(ch_present_A2_br3, by: 0)

    process allele_correction_A1_A2 {

        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev
        publishDir "${params.outdir}/${datasetID}/intermediates/removed_lines", mode: 'symlink', overwrite: true, pattern: 'removed_*', enabled: params.dev

        input:
        tuple datasetID, build, mfile, mapped, sfile, A2exists from ch_A2_exists

        output:
        tuple datasetID, build, mfile, file("${build}_acorrected") into ch_A2_exists2
        tuple datasetID, file("removed_allele_filter_ix") into ch_removed_by_allele_filter_ix1
        tuple datasetID, file("desc_filtered_allele-pairs_with_dbsnp_as_reference") into ch_desc_filtered_allele_pairs_with_dbsnp_as_reference_A1A2_BA

        script:
        """
        echo -e "0\tA1\tA2\tCHRPOS\tRSID\tEffectAllele\tOtherAllele\tEMOD" > ${build}_acorrected

        #init some the files collecting variants removed because of allele composition
        touch removed_notGCTA
        touch removed_indel
        touch removed_hom
        touch removed_palin
        touch removed_notPossPair
        touch removed_notExpA2

        colA1=\$(map_to_adhoc_function.sh ${ch_regexp_lexicon} ${mfile} ${sfile} "effallele")
        colA2=\$(map_to_adhoc_function.sh ${ch_regexp_lexicon} ${mfile} ${sfile} "altallele")
        cat ${sfile} | sstools-utils ad-hoc-do -k "0|\${colA1}|\${colA2}" -n"0,A1,A2" | LC_ALL=C join -t "\$(printf '\t')" -o 1.1 1.2 1.3 2.2 2.3 2.4 2.5 -1 1 -2 1 - ${mapped} | tail -n+2 | sstools-eallele correction -f - >> ${build}_acorrected

        #only keep the index to prepare for the file with all removed lines
        touch removed_allele_filter_ix
        awk -vOFS="\t" '{print \$1,"notGCTA"}' removed_notGCTA >> removed_allele_filter_ix
        awk -vOFS="\t" '{print \$1,"indel"}' removed_indel >> removed_allele_filter_ix
        awk -vOFS="\t" '{print \$1,"hom"}' removed_hom >> removed_allele_filter_ix
        awk -vOFS="\t" '{print \$1,"palin"}' removed_palin >> removed_allele_filter_ix
        awk -vOFS="\t" '{print \$1,"notPossPair"}' removed_notPossPair >> removed_allele_filter_ix
        awk -vOFS="\t" '{print \$1,"notExpA2"}' removed_notExpA2 >> removed_allele_filter_ix

        #process before and after stats (create one for each discarded filter, the original before after concept where all output files are directly tested is a bit violated here as we have to count down from input file)
        rowsBefore="\$(wc -l ${mapped} | awk '{print \$1-1}')"
        rowsAfter="\$(wc -l removed_notGCTA | awk -vrb=\${rowsBefore} '{ra=rb-\$1; print ra}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFiltered rows on nonGTAC characters" >> desc_filtered_allele-pairs_with_dbsnp_as_reference

        rowsBefore="\${rowsAfter}"
        rowsAfter="\$(wc -l removed_indel | awk -vrb=\${rowsBefore} '{ra=rb-\$1; print ra}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFiltered rows on indels. All indels in the dbsnp reference are already filtered out" >> desc_filtered_allele-pairs_with_dbsnp_as_reference

        rowsBefore="\${rowsAfter}"
        rowsAfter="\$(wc -l removed_hom | awk -vrb=\${rowsBefore} '{ra=rb-\$1; print ra}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFiltered rows on homozygotes. Should be rare." >> desc_filtered_allele-pairs_with_dbsnp_as_reference

        rowsBefore="\${rowsAfter}"
        rowsAfter="\$(wc -l removed_palin | awk -vrb=\${rowsBefore} '{ra=rb-\$1; print ra}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFiltered rows on palindromes. Usually a substantial amount." >> desc_filtered_allele-pairs_with_dbsnp_as_reference

        rowsBefore="\${rowsAfter}"
        rowsAfter="\$(wc -l removed_notPossPair | awk -vrb=\${rowsBefore} '{ra=rb-\$1; print ra}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFiltered rows on not possible pair combinations comparing with reference db. Many multi-allelic sites are filtered out here" >> desc_filtered_allele-pairs_with_dbsnp_as_reference

        rowsBefore="\${rowsAfter}"
        rowsAfter="\$(wc -l removed_notExpA2 | awk -vrb=\${rowsBefore} '{ra=rb-\$1; print ra}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFiltered rows on not expected otherAllele in reference db" >> desc_filtered_allele-pairs_with_dbsnp_as_reference

        rowsBefore="\${rowsAfter}"
        rowsAfter="\$(wc -l ${build}_acorrected | awk '{print \$1-1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tAllele corretion sanity check that final filtered file before and after file have same row count" >> desc_filtered_allele-pairs_with_dbsnp_as_reference
        """


    }

    process allele_correction_A1 {

        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev
        publishDir "${params.outdir}/${datasetID}/intermediates/removed_lines", mode: 'symlink', overwrite: true, pattern: 'removed_*', enabled: params.dev

        input:
        tuple datasetID, build, mfile, mapped, sfile, A2missing from ch_A2_missing

        output:
        tuple datasetID, build, mfile, file("${build}_acorrected") into ch_A2_missing2
        tuple datasetID, file("removed_allele_filter_ix") into ch_removed_by_allele_filter_ix2
        tuple datasetID, file("desc_filtered_allele-pairs_with_dbsnp_as_reference") into ch_desc_filtered_allele_pairs_with_dbsnp_as_reference_A1_BA
        file("${build}_mapped2")

        script:
        """

        #NOTE to use A1 allele only complicates the filtering on possible pairs etc, so we always need a multiallelic filter in how the filter works right now.
        # This is something we should try to accomodate to, so that it is not required.
        multiallelic_filter.sh $mapped > ${build}_mapped2
        echo -e "0\tA1\tA2\tCHRPOS\tRSID\tEffectAllele\tOtherAllele\tEMOD" > ${build}_acorrected

        #init some the files collecting variants removed because of allele composition
        touch removed_notGCTA
        touch removed_indel
        touch removed_hom
        touch removed_palin
        touch removed_notPossPair
        touch removed_notExpA2

        colA1=\$(map_to_adhoc_function.sh ${ch_regexp_lexicon} ${mfile} ${sfile} "effallele")
        cat ${sfile} | sstools-utils ad-hoc-do -k "0|\${colA1}" -n"0,A1" | LC_ALL=C join -t "\$(printf '\t')" -o 1.1 1.2 2.2 2.3 2.4 2.5 -1 1 -2 1 - ${build}_mapped2 | tail -n+2 | sstools-eallele correction -f - -a >> ${build}_acorrected

        #only keep the index to prepare for the file with all removed lines
        touch removed_allele_filter_ix
        awk -vOFS="\t" '{print \$1,"notGCTA"}' removed_notGCTA >> removed_allele_filter_ix
        awk -vOFS="\t" '{print \$1,"indel"}' removed_indel >> removed_allele_filter_ix
        awk -vOFS="\t" '{print \$1,"hom"}' removed_hom >> removed_allele_filter_ix
        awk -vOFS="\t" '{print \$1,"palin"}' removed_palin >> removed_allele_filter_ix
        awk -vOFS="\t" '{print \$1,"notPossPair"}' removed_notPossPair >> removed_allele_filter_ix
        awk -vOFS="\t" '{print \$1,"notExpA2"}' removed_notExpA2 >> removed_allele_filter_ix

        #process before and after stats (create one for each discarded filter, the original before after concept where all output files are directly tested is a bit violated here as we have to count down from input file)
        rowsBefore="\$(wc -l ${mapped} | awk '{print \$1-1}')"
        rowsAfter="\$(wc -l removed_notGCTA | awk -vrb=\${rowsBefore} '{ra=rb-\$1; print ra}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFiltered rows on nonGTAC characters" >> desc_filtered_allele-pairs_with_dbsnp_as_reference

        rowsBefore="\${rowsAfter}"
        rowsAfter="\$(wc -l removed_indel | awk -vrb=\${rowsBefore} '{ra=rb-\$1; print ra}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFiltered rows on indels. All indels in the dbsnp reference are already filtered out" >> desc_filtered_allele-pairs_with_dbsnp_as_reference

        rowsBefore="\${rowsAfter}"
        rowsAfter="\$(wc -l removed_hom | awk -vrb=\${rowsBefore} '{ra=rb-\$1; print ra}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFiltered rows on homozygotes. Should be rare." >> desc_filtered_allele-pairs_with_dbsnp_as_reference

        rowsBefore="\${rowsAfter}"
        rowsAfter="\$(wc -l removed_palin | awk -vrb=\${rowsBefore} '{ra=rb-\$1; print ra}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFiltered rows on palindromes" >> desc_filtered_allele-pairs_with_dbsnp_as_reference

        rowsBefore="\${rowsAfter}"
        rowsAfter="\$(wc -l removed_notPossPair | awk -vrb=\${rowsBefore} '{ra=rb-\$1; print ra}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFiltered rows on not possible pair combinations comparing with reference db. Many multi-allelic sites are filtered out here" >> desc_filtered_allele-pairs_with_dbsnp_as_reference

        rowsBefore="\${rowsAfter}"
        rowsAfter="\$(wc -l removed_notExpA2 | awk -vrb=\${rowsBefore} '{ra=rb-\$1; print ra}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFiltered rows on not expected otherAllele in reference db" >> desc_filtered_allele-pairs_with_dbsnp_as_reference

        rowsBefore="\${rowsAfter}"
        rowsAfter="\$(wc -l ${build}_acorrected | awk '{print \$1-1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tsanity sanity check that final filtered file before and after file have same row count" >> desc_filtered_allele-pairs_with_dbsnp_as_reference

        """
    }

    //put the two brances into the same channel (as only one will be used per file, there will be no duplicates)
    ch_removed_by_allele_filter_ix1
      .mix(ch_removed_by_allele_filter_ix2)
      .set{ ch_removed_by_allele_filter_ix }


    ch_desc_filtered_allele_pairs_with_dbsnp_as_reference_A1A2_BA
      .mix(ch_desc_filtered_allele_pairs_with_dbsnp_as_reference_A1_BA)
      .set{ ch_desc_filtered_allele_pairs_with_dbsnp_as_reference_BA }


    //mix the A1_A2_both and A1_solo channels
    ch_A2_exists2
      .mix(ch_A2_missing2)
      .set{ ch_allele_corrected_mix_X }

    process remove_duplicated_chr_position_rows {

        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, build, mfile, acorrected from ch_allele_corrected_mix_X

        output:
        tuple datasetID, build, mfile, file("ac_unique_rows_sorted") into ch_allele_corrected_mix_Y
        tuple datasetID, file("desc_removed_duplicated_rows") into ch_desc_removed_duplicated_chr_pos_rows_BA
        file("ac_*")
        file("afterAlleleCorrection_executionorder")
        file("removed_*")

        script:
        """

        #Can be used as a sanitycheck-filter to discover potential misbehaviour
        filter_after_allele_correction.sh $acorrected ${afterAlleleCorrectionFilter}

        """
    }
    ch_allele_corrected_mix_Y
      .into{ ch_allele_corrected_mix1; ch_allele_corrected_mix2; ch_allele_corrected_mix3 }

    process filter_stats_on_interpretable_values {

        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev
        publishDir "${params.outdir}/${datasetID}/intermediates/removed_lines", mode: 'symlink', overwrite: true, pattern: 'removed_*', enabled: params.dev

        input:
        tuple datasetID, mfile, sfile from ch_stats_inference

        output:
        tuple datasetID, mfile, file("st_filtered_remains") into ch_stats_filtered_remain00
        tuple datasetID, file("removed_stat_non_numeric_in_awk")
        tuple datasetID, file("removed_stat_non_numeric_in_awk_ix") into ch_stats_filtered_removed_ix
        tuple datasetID, file("desc_filtered_stat_rows_with_non_numbers_BA.txt") into ch_desc_filtered_stat_rows_with_non_numbers_BA

        script:
        """
        touch removed_stat_non_numeric_in_awk
        touch removed_stat_non_numeric_in_awk_ix
        filter_stat_values.sh $mfile $sfile > st_filtered_remains 2> removed_stat_non_numeric_in_awk
        awk -vOFS="\t" '{print \$1,"stat_non_numeric_in_awk"}' removed_stat_non_numeric_in_awk > removed_stat_non_numeric_in_awk_ix

        #process before and after stats
        rowsBefore="\$(wc -l ${sfile} | awk '{print \$1}')"
        rowsAfter="\$(wc -l st_filtered_remains | awk '{print \$1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFiltered out rows with stats impossible to do calculations from" > desc_filtered_stat_rows_with_non_numbers_BA.txt
        """
    }

    process force_effect_allele_frequency {

        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, mfile, sfile from ch_stats_filtered_remain00

        output:
        tuple datasetID, file("st_forced_eaf") into ch_stats_filtered_remain
        tuple datasetID, file("desc_forced_eaf_BA.txt") into ch_desc_forced_eaf_BA

        script:
        """
        force_effect_allele_frequency.sh $mfile $sfile > st_forced_eaf

        #process before and after stats
        rowsBefore="\$(wc -l ${sfile} | awk '{print \$1}')"
        rowsAfter="\$(wc -l st_forced_eaf | awk '{print \$1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tForced Effect Allele Frequency" > desc_forced_eaf_BA.txt
        """
    }

    ch_stats_filtered_remain
      .join(ch_mfile_ok5, by: 0)
      .set{ ch_stats_filtered_remain3 }




    process prepare_allele_frequency_stats {

        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, build, mfile, sfile from ch_allele_corrected_mix3

        output:
        tuple datasetID, env(avail), file("st_1kg_af_ref_sorted_joined_sorted_on_inx") into ch_prep_ref_allele_frequency
        file("st_1kg_af_ref_sorted")
        file("st_1kg_af_ref_sorted_joined")

        script:
        """

        # Check if the ancestry is one of the ones we have frequencies for (EAS, EUR, AFR, AMR, SAS)
        Ax="\$(grep "^study_Ancestry=" $mfile)"
        A="\$(echo "\${Ax#*=}")"

        avail="false"
        count=0
        #important that this order is the same as in the allele frequency file
        for anc in EAS EUR AFR AMR SAS; do
          if [ "\${anc}" == "\${A}" ]; then
            avail="true"
          fi
          count=\$((count+1))
        done

        # If we have an available ancestry reference frequency
        if [ \${avail} == "true" ]; then
          # Join with AF table using chrpos column (keep only rowindex and allele frequency, merge later)
          awk -vFS="\t" -vOFS="\t" '{print \$4"-"\$2"-"\$3, \$1}' ${sfile} | C_ALL=C sort -t "\$(printf '\t')" -k 1,1 > st_1kg_af_ref_sorted
          awk -vFS="\t" -vOFS="\t" -vcount=\${count} '{print \$1"-"\$2"-"\$3,\$count}' ${ch_kg1000AFGRCh38} | LC_ALL=C join -1 1 -2 1 -t "\$(printf '\t')" -o 2.2 1.2 - st_1kg_af_ref_sorted > st_1kg_af_ref_sorted_joined
          echo -e "0\tAF_1KG_CS" > st_1kg_af_ref_sorted_joined_sorted_on_inx
          LC_ALL=C sort -k 1,1 st_1kg_af_ref_sorted_joined >> st_1kg_af_ref_sorted_joined_sorted_on_inx
        else
          touch st_1kg_af_ref_sorted
          touch st_1kg_af_ref_sorted_joined
          touch st_1kg_af_ref_sorted_joined_sorted_on_inx
        fi

        """
    }

    ch_stats_filtered_remain3
    .join(ch_prep_ref_allele_frequency, by: 0)
    .set { ch_add_ref_freq }


    //if available, add allele_frequency
    process add_allele_frequency_stats {

        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, st_filtered, mfile, availAF, afFreqs from ch_add_ref_freq

        output:
        tuple datasetID, val("g1kaf_stats_branch"), file("st_added_1kg_ref"), mfile into ch_added_ref_allele_frequency_kg
        tuple datasetID, val("default_stats_branch"), file("st_added_1kg_ref"), mfile into ch_added_ref_allele_frequency_default

        script:
        """

        # If we have an available ancestry reference frequency
        if [ "${availAF}" == "true" ]; then
          # Join with AF table using chrpos column add NA for missing fields
         LC_ALL=C join -e "NA" -t "\$(printf '\t')" -a 1 -1 1 -2 1 -o auto ${st_filtered} ${afFreqs} > st_added_1kg_ref
        else
          head -n1 ${st_filtered} > st_added_1kg_ref
        fi

        """
    }
    //re-merge these stats in the select_stats process
    ch_added_ref_allele_frequency_default.into{ ch_added_ref_allele_frequency_default1; ch_added_ref_allele_frequency_default2 }

    //mix and run inference for 1kg-AF version and for a version without
    ch_added_ref_allele_frequency_kg
      .mix(ch_added_ref_allele_frequency_default1)
      .set{ ch_stats_to_infer }

    process infer_stats {

        publishDir "${params.outdir}/${datasetID}/intermediates/${af_branch}", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, af_branch, st_filtered, mfile from ch_stats_to_infer

        output:
        tuple datasetID, af_branch, mfile, file("st_inferred_stats") into ch_stats_selection
        tuple datasetID, file("desc_inferred_stats_if_inferred_BA.txt") into ch_desc_inferred_stats_if_inferred_BA
        file("st_which_to_infer")
        file("colfields")
        file("colnames")
        file("colpositions")

        script:
        """
        check_stat_inference_functionfile.sh ${mfile} $af_branch > st_which_to_infer
        check_stat_inference_avail.sh $mfile colfields colnames colpositions $af_branch

        cf="\$(cat colfields)"
        cn="\$(cat colnames)"
        cp="\$(cat colpositions)"

        if [ -s st_which_to_infer ]; then

        thisdir="\$(pwd)"

        cat $st_filtered | sstools-utils ad-hoc-do -f - -k "\${cf}" -n"\${cn}" | r-stats-c-streamer --functionfile  /mnt/st_which_to_infer --skiplines 1 \${cp} --statmodel lin --allelefreqswitch > st_inferred_stats

        else
          touch st_inferred_stats
        fi

        #process before and after stats
        rowsBefore="\$(wc -l ${st_filtered} | awk '{print \$1}')"
        rowsAfter="\$(wc -l st_inferred_stats | awk '{print \$1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tInferred stats, if stats are inferred" > desc_inferred_stats_if_inferred_BA.txt
        """
    }


    //branch the stats_genome_build
    ch_stats_selection_filter=ch_stats_selection.branch { key, value, file1, file2 ->
                    g1kaf_stats_branch: value == "g1kaf_stats_branch"
                    default_stats_branch: value == "default_stats_branch"
                    }
    g1kaf_stats_branch=ch_stats_selection_filter.g1kaf_stats_branch
    default_stats_branch=ch_stats_selection_filter.default_stats_branch

    //combine the 1kg af branch and default branch for inferred information
    g1kaf_stats_branch
      .join(default_stats_branch, by: 0)
      .map { key, val, mfile, file, val2, mfile2, file2 -> tuple(key, mfile, file, file2) }
      .set{ ch_inferred_stats_combined }

    process merge_inferred_data {

      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple datasetID, mfile, kgversion, defaultversion from ch_inferred_stats_combined

      output:
      tuple datasetID, file("st_combined_set_of_inferred_data") into ch_combined_set_of_inferred_data
      file("st_added_suffix")

      script:
      """
      # Add _1KG to all 1KG inferred variables
      add_suffix_to_colnames.sh $kgversion "_1KG" > st_added_suffix

      # Merge the data add NA for missing fields
      LC_ALL=C join -e "NA" -t "\$(printf '\t')" -a 1 -1 1 -2 1 -o auto $defaultversion st_added_suffix > st_combined_set_of_inferred_data
      """

    }

    //ch_liftover_final.view()




    //ch_stats_selection_only_contains_inferred_variables
    ch_combined_set_of_inferred_data
      .join(ch_added_ref_allele_frequency_default2, by: 0)
      .set{ ch_stats_selection2 }

    process select_stats {

        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, inferred, stats_branch, sfile, mfile from ch_stats_selection2

        output:
        tuple datasetID, file("st_stats_for_output") into ch_stats_for_output
        tuple datasetID, file("desc_from_inferred_to_joined_selection_BA.txt") into ch_desc_from_inferred_to_joined_selection_BA
        tuple datasetID, file("desc_from_sumstats_to_joined_selection_BA.txt") into ch_desc_from_sumstats_to_joined_selection_BA

        script:
        """
        select_stats_for_output.sh $mfile $sfile $inferred > st_stats_for_output

        #process before and after stats
        rowsBefore="\$(wc -l ${inferred} | awk '{print \$1}')"
        rowsAfter="\$(wc -l st_stats_for_output | awk '{print \$1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFrom inferred to joined selection of stats" > desc_from_inferred_to_joined_selection_BA.txt

        #process before and after stats
        rowsBefore="\$(wc -l ${sfile} | awk '{print \$1}')"
        rowsAfter="\$(wc -l st_stats_for_output | awk '{print \$1}')"
        echo -e "\$rowsBefore\t\$rowsAfter\tFrom raw sumstat to joined selection of stats" > desc_from_sumstats_to_joined_selection_BA.txt
        """
    }



    ch_allele_corrected_mix1
      .combine(ch_stats_for_output, by: 0)
      .set{ ch_allele_corrected_and_outstats }

  process final_assembly {

      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple datasetID, build, mfile, acorrected, stats from ch_allele_corrected_and_outstats

      output:
      tuple datasetID, file("${datasetID}_cleaned"), file("header") into ch_cleaned_file_1
      tuple datasetID, file("desc_final_merge_BA.txt") into ch_desc_final_merge_BA

      script:
      """
      apply_modifier_on_stats.sh $acorrected $stats > cleaned

      #sort on chrpos (which will make header not on top, so lift that out, and prepare order for next process)
      head -n1 cleaned | awk -vFS="\t" -vOFS="\t" '{printf "%s%s%s%s%s%s", \$2, OFS, \$3, OFS, \$1, OFS; for(i=4; i<=NF-1; i++){printf "%s%s", \$i, OFS}; print \$NF}' > header
      awk -vFS="\t" -vOFS="\t" 'NR>1{printf "%s%s%s%s", \$2":"\$3, OFS, \$1, OFS; for(i=4; i<=NF-1; i++){printf "%s%s", \$i, OFS}; print \$NF}' cleaned | LC_ALL=C sort -k1,1 > ${datasetID}_cleaned

      # process before and after stats
      rowsBefore="\$(wc -l $acorrected | awk '{print \$1}')"
      rowsAfter="\$(wc -l ${datasetID}_cleaned | awk '{print \$1}')"
      echo -e "\$rowsBefore\t\$rowsAfter\tFrom dbsnp mapped to merged selection of stats, final step" > desc_final_merge_BA.txt
      """
  }

  process final_assembly_make_GRCh37_reference {

      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple datasetID, cleaned_chrpos_sorted, header from ch_cleaned_file_1

      output:
      tuple datasetID, file("cleaned_chrpos_sorted_header"), file("cleaned_GRCh37") into ch_cleaned_file
      //file("cleaned_chrpos_sorted")
      //file("inx_chrpos_GRCh37")

      script:

      """
      echo -e "CHR\tPOS\tRSID" > cleaned_GRCh37
      LC_ALL=C join -e "NA" -a1 -1 1 -2 1 -o 2.1 2.2 2.3 ${cleaned_chrpos_sorted} ${ch_dbsnp_38_37} | awk -vOFS="\t" '{split(\$2,out,":"); print out[1], out[2],\$3 }' >> cleaned_GRCh37
      cat $header > cleaned_chrpos_sorted_header
      awk -vFS="\t" -vOFS="\t" '{split(\$1,out,":");printf "%s%s%s%s", out[1], OFS, out[2], OFS; for(i=2; i<=NF-1; i++){printf "%s%s", \$i, OFS}; print \$NF}' $cleaned_chrpos_sorted >> cleaned_chrpos_sorted_header
      """

  }

    //Collect and place in corresponding stepwise order
    ch_removed_not_possible_to_lift_over_for_combined_set_ix
     .join(ch_removed_by_allele_filter_ix, by: 0)
     .join(ch_stats_filtered_removed_ix, by: 0)
     .set{ ch_collected_removed_lines }

    process collect_all_removed_lines {
        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, step1, step2, step3 from ch_collected_removed_lines

        output:
        tuple datasetID, file("removed_lines_collected.txt") into ch_collected_removed_lines2

        script:
        """
        echo -e "RowIndex\tExclusionReason" > removed_lines_collected.txt
        cat ${step1} ${step2} ${step3} >> removed_lines_collected.txt
        """
    }

    ch_collected_removed_lines2
      .into { ch_collected_removed_lines3; ch_collected_removed_lines4 }

    process describe_removed_lines_as_table {

      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, filtered_stats_removed from ch_collected_removed_lines3

        output:
        tuple datasetID, file("desc_removed_lines_table.txt") into ch_removed_lines_table

        script:
        """
        # prepare process specific descriptive statistics
        echo -e "NrExcludedRows\tExclusionReason" > desc_removed_lines_table.txt
        cat $filtered_stats_removed | tail -n+2 | awk -vOFS="\t" '{ seen[\$2] += 1 } END { for (i in seen) print seen[i],i }' >> desc_removed_lines_table.txt

        """
    }


    ch_cleaned_file
      .combine(ch_input_sfile2, by: 0)
      .combine(ch_sfile_on_stream5, by: 0)
      .combine(ch_collected_removed_lines4, by: 0)
      .set{ ch_to_write_to_filelibrary2 }

    process gzip_outfiles {
        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, sclean, scleanGRCh37, inputsfile, inputformatted, removedlines from ch_to_write_to_filelibrary2

        output:
        tuple datasetID, path("sclean.gz"), path("scleanGRCh37.gz"), path("removed_lines.gz") into ch_to_write_to_filelibrary3
        tuple datasetID, path("cleanedheader") into ch_cleaned_header
        tuple datasetID, inputsfile into ch_to_write_to_raw_library
        val datasetID into ch_check_avail

        script:
        """
        # Make a header file to use when deciding on what cols are present for the new meta file
        head -n1 ${sclean} > cleanedheader

        # Store data in library
        gzip -c ${sclean} > sclean.gz
        gzip -c ${scleanGRCh37} > scleanGRCh37.gz
        #gzip -c ${inputformatted} > raw_formatted_rowindexed.gz
        gzip -c ${removedlines} > removed_lines.gz
        """
    }

    ch_to_write_to_filelibrary3.into { ch_to_write_to_filelibrary3a; ch_to_write_to_filelibrary3b }

    process calculate_checksum_on_cleaned_sumstat {
        publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, sclean, scleanGRCh37, removedlines from ch_to_write_to_filelibrary3a

        output:
        tuple datasetID, env(scleanchecksum), env(scleanGRCh37checksum), env(removedlineschecksum) into ch_cleaned_sumstat_checksums

        script:
        """
        scleanchecksum="\$(b3sum ${sclean} | awk '{print \$1}')"
        scleanGRCh37checksum="\$(b3sum ${scleanGRCh37} | awk '{print \$1}')"
        removedlineschecksum="\$(b3sum ${removedlines} | awk '{print \$1}')"
        """
    }

  ch_cleaned_sumstat_checksums.into { ch_cleaned_sumstat_checksums1; ch_cleaned_sumstat_checksums2 }


  //Do actual collection, placed in corresponding step order
  ch_desc_prep_force_tab_sep_BA
   .combine(ch_desc_prep_add_sorted_rowindex_BA, by: 0)
   .combine(ch_desc_combined_set_after_liftover, by: 0)
   .combine(ch_desc_removed_duplicates_after_liftover, by: 0)
   .combine(ch_desc_keep_a_GRCh38_reference_BA, by: 0)
   .combine(ch_desc_split_multi_allelics_and_sort_on_rowindex_BA, by: 0)
   .combine(ch_desc_filtered_allele_pairs_with_dbsnp_as_reference_BA, by: 0)
   .combine(ch_desc_removed_duplicated_chr_pos_rows_BA, by: 0)
   .combine(ch_desc_filtered_stat_rows_with_non_numbers_BA, by: 0)
   .combine(ch_desc_inferred_stats_if_inferred_BA, by: 0)
   .combine(ch_desc_from_inferred_to_joined_selection_BA, by: 0)
   .combine(ch_desc_from_sumstats_to_joined_selection_BA, by: 0)
   .combine(ch_desc_final_merge_BA, by: 0)
   .set{ ch_collected_workflow_stepwise_stats }

 //Some that now are part of the branched workflow. Unclear how to save the the stepwise branched workflow before after steps, but all info should be exported in channels.
 //  .combine(ch_desc_sex_chrom_formatting_BA, by: 0)
 //  .combine(ch_desc_prep_for_dbsnp_mapping_BA, by: 0)
 //  .combine(ch_removed_rows_before_liftover, by: 0)
 //  .combine(ch_desc_liftover_to_GRCh38_and_map_to_dbsnp_BA, by: 0)

  process collect_and_prepare_stepwise_readme {
      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

      input:
      tuple datasetID, step1, step2, step3, step4, step5, step6, step7, step8, step9, step10, step11, step12, step13 from ch_collected_workflow_stepwise_stats

      output:
      tuple datasetID, file("desc_collected_workflow_stepwise_stats.txt") into ch_overview_workflow_steps

      script:
      """
      cat $step1 $step2 $step3 $step4 $step5 $step6 $step7 $step8 $step9 $step10 $step11 $step12 $step13 > all_removed_steps

      echo -e "Steps\tBefore\tAfter\tDescription" > desc_collected_workflow_stepwise_stats.txt
      awk -vFS="\t" -vOFS="\t" '{print "Step"NR, \$1, \$2, \$3}' all_removed_steps >> desc_collected_workflow_stepwise_stats.txt

      """
  }

      ch_mfile_ok4
      .combine(ch_cleaned_sumstat_checksums2, by: 0)
      .combine(ch_cleaned_header, by: 0)
      .set { ch_mfile_cleaned_x }

    process prepare_cleaned_metadata_file {
      publishDir "${params.outdir}/${datasetID}/intermediates", mode: 'symlink', overwrite: true, enabled: params.dev

        input:
        tuple datasetID, mfile, scleanchecksum, scleanGRCh37checksum, removedlineschecksum, cleanedheader from ch_mfile_cleaned_x

        output:
        tuple datasetID, path("prepared_cleaned_metafile") into ch_mfile_cleaned_1

        script:
        """

        #Add cleaned output lines
        dateOfCreation="\$(date +%F-%H%M)"
        echo "cleansumstats_date=\${dateOfCreation}" > mfile_additions
        echo "cleansumstats_user=\$(id -u -n)" >> mfile_additions
        echo "cleansumstats_cleaned_GRCh38=sumstat_cleaned_GRCh38.gz" >> mfile_additions
        echo "cleansumstats_cleaned_GRCh38_checksum=${scleanchecksum}" >> mfile_additions
        echo "cleansumstats_cleaned_GRCh37_coordinates=sumstat_cleaned_GRCh37.gz" >> mfile_additions
        echo "cleansumstats_cleaned_GRCh37_coordinates_checksum=${scleanGRCh37checksum}" >> mfile_additions
        echo "cleansumstats_removed_lines=sumstat_removed_lines.gz" >> mfile_additions
        echo "cleansumstats_removed_lines_checksum=${removedlineschecksum}" >> mfile_additions

        #Calcualate effective N using meta data info
        try_infere_Neffective.sh ${mfile} >> mfile_additions

        # Apply additions to make the cleaned meta file ready
        create_output_meta_data_file_cleaned.sh mfile_additions ${cleanedheader} > prepared_cleaned_metafile

        """
    }


    // Collect all metafiles in one channel
     ch_mfile_user_2
     .combine(ch_mfile_cleaned_1, by: 0)
     .set { ch_all_mfiles }

     ch_to_write_to_filelibrary3b
      .join(ch_input_readme, by: 0)
      .join(ch_overview_workflow_steps, by: 0)
      .join(ch_removed_lines_table, by: 0)
      .join(ch_gb_stats_combined, by: 0)
      .join(ch_all_mfiles, by: 0)
      .join(ch_to_write_to_raw_library, by: 0)
      .join(ch_input_pdf_stuff, by: 0)
      .set{ ch_to_write_to_filelibrary7 }


     //.combine(ch_collected_removed_lines2)

    process put_in_cleaned_library {

        publishDir "${params.outdir}/${datasetID}", mode: 'copy', overwrite: true

        input:
        tuple datasetID, sclean, scleanGRCh37, removedlines, readme, overviewworkflow, removedlinestable, gbdetectCHRPOS, gbdetectSNPCHRPOS, usermfile, cleanmfile, rawfile, pmid, pdfpath, pdfsuppdir from ch_to_write_to_filelibrary7

        output:
        path("*")

        script:

        """
        # Store data in library by copying (move is faster, but debug gets slower as input disappears)
        cp ${sclean} cleaned_GRCh38.gz
        cp ${scleanGRCh37} cleaned_GRCh37.gz

        # Make a folder with detailed data of the cleaning
        mkdir details
        cp $overviewworkflow details/stepwise_overview.txt
        cp ${removedlinestable} details/removed_lines_per_type_table.txt
        cp $gbdetectCHRPOS details/genome_build_map_count_table_chrpos.txt
        cp $gbdetectSNPCHRPOS details/genome_build_map_count_table_markername.txt
        cp ${removedlines} details/removed_lines.gz
        cp ${cleanmfile} cleaned_metadata.txt

        # copy all raw stuff into raw
        mkdir raw
        cp ${rawfile} raw/.
        cp ${usermfile} raw/.

        #reference material
        mkdir raw/reference
        mkdir raw/reference/supplemental_material

        if [ "${pdfpath}" != "missing" ]
        then
          cp ${pdfpath} raw/reference/.
        fi

        cat ${pdfsuppdir} | while read -r supp; do
           if [ "\${supp}" != "missing" ]
           then
             cp \$supp raw/reference/supplemental_material/.
           else
             :
           fi
        done
        """
    }
  }
}

/*
 * Completion e-mail notification
 */
workflow.onComplete {

    // Set up the e-mail variables
    def subject = "[nf-core/cleansumstats] Successful: $workflow.runName"
    if (!workflow.success) {
      subject = "[nf-core/cleansumstats] FAILED: $workflow.runName"
    }
    def email_fields = [:]
    email_fields['version'] = workflow.manifest.version
    email_fields['runName'] = custom_runName ?: workflow.runName
    email_fields['success'] = workflow.success
    email_fields['dateComplete'] = workflow.complete
    email_fields['duration'] = workflow.duration
    email_fields['exitStatus'] = workflow.exitStatus
    email_fields['errorMessage'] = (workflow.errorMessage ?: 'None')
    email_fields['errorReport'] = (workflow.errorReport ?: 'None')
    email_fields['commandLine'] = workflow.commandLine
    email_fields['projectDir'] = workflow.projectDir
    email_fields['summary'] = summary
    email_fields['summary']['Date Started'] = workflow.start
    email_fields['summary']['Date Completed'] = workflow.complete
    email_fields['summary']['Pipeline script file path'] = workflow.scriptFile
    email_fields['summary']['Pipeline script hash ID'] = workflow.scriptId
    if (workflow.repository) email_fields['summary']['Pipeline repository Git URL'] = workflow.repository
    if (workflow.commitId) email_fields['summary']['Pipeline repository Git Commit'] = workflow.commitId
    if (workflow.revision) email_fields['summary']['Pipeline Git branch/tag'] = workflow.revision
    if (workflow.container) email_fields['summary']['Docker image'] = workflow.container
    email_fields['summary']['Nextflow Version'] = workflow.nextflow.version
    email_fields['summary']['Nextflow Build'] = workflow.nextflow.build
    email_fields['summary']['Nextflow Compile Timestamp'] = workflow.nextflow.timestamp

    // Check if we are only sending emails on failure
    email_address = params.email
    if (!params.email && params.email_on_fail && !workflow.success) {
        email_address = params.email_on_fail
    }

    // Render the TXT template
    def engine = new groovy.text.GStringTemplateEngine()
    def tf = new File("$baseDir/assets/email_template.txt")
    def txt_template = engine.createTemplate(tf).make(email_fields)
    def email_txt = txt_template.toString()

    // Render the HTML template
    def hf = new File("$baseDir/assets/email_template.html")
    def html_template = engine.createTemplate(hf).make(email_fields)
    def email_html = html_template.toString()

    // Render the sendmail template
    def smail_fields = [ email: email_address, subject: subject, email_txt: email_txt, email_html: email_html, baseDir: "$baseDir", mqcFile: mqc_report, mqcMaxSize: params.maxMultiqcEmailFileSize.toBytes() ]
    def sf = new File("$baseDir/assets/sendmail_template.txt")
    def sendmail_template = engine.createTemplate(sf).make(smail_fields)
    def sendmail_html = sendmail_template.toString()

    // Send the HTML e-mail
    if (email_address) {
        try {
          if ( params.plaintext_email ){ throw GroovyException('Send plaintext e-mail, not HTML') }
          // Try to send HTML e-mail using sendmail
          [ 'sendmail', '-t' ].execute() << sendmail_html
          log.info "[nf-core/cleansumstats] Sent summary e-mail to $email_address (sendmail)"
        } catch (all) {
          // Catch failures and try with plaintext
          [ 'mail', '-s', subject, email_address ].execute() << email_txt
          log.info "[nf-core/cleansumstats] Sent summary e-mail to $email_address (mail)"
        }
    }

    // Write summary e-mail HTML to a file
    def output_d = new File( "${params.outdir}/pipeline_info/" )
    if (!output_d.exists()) {
      output_d.mkdirs()
    }
    def output_hf = new File( output_d, "pipeline_report.html" )
    output_hf.withWriter { w -> w << email_html }
    def output_tf = new File( output_d, "pipeline_report.txt" )
    output_tf.withWriter { w -> w << email_txt }

    c_reset = params.monochrome_logs ? '' : "\033[0m";
    c_purple = params.monochrome_logs ? '' : "\033[0;35m";
    c_green = params.monochrome_logs ? '' : "\033[0;32m";
    c_red = params.monochrome_logs ? '' : "\033[0;31m";

    if (workflow.stats.ignoredCount > 0 && workflow.success) {
      log.info "${c_purple}Warning, pipeline completed, but with errored process(es) ${c_reset}"
      log.info "${c_red}Number of ignored errored process(es) : ${workflow.stats.ignoredCount} ${c_reset}"
      log.info "${c_green}Number of successfully ran process(es) : ${workflow.stats.succeedCount} ${c_reset}"
    }

    if (workflow.success) {
        log.info "${c_purple}[nf-core/cleansumstats]${c_green} Pipeline completed successfully${c_reset}"
    } else {
        checkHostname()
        log.info "${c_purple}[nf-core/cleansumstats]${c_red} Pipeline completed with errors${c_reset}"
    }

}


def nfcoreHeader(){
    // Log colors ANSI codes
    c_reset = params.monochrome_logs ? '' : "\033[0m";
    c_dim = params.monochrome_logs ? '' : "\033[2m";
    c_black = params.monochrome_logs ? '' : "\033[0;30m";
    c_green = params.monochrome_logs ? '' : "\033[0;32m";
    c_yellow = params.monochrome_logs ? '' : "\033[0;33m";
    c_blue = params.monochrome_logs ? '' : "\033[0;34m";
    c_purple = params.monochrome_logs ? '' : "\033[0;35m";
    c_cyan = params.monochrome_logs ? '' : "\033[0;36m";
    c_white = params.monochrome_logs ? '' : "\033[0;37m";

    return """    -${c_dim}--------------------------------------------------${c_reset}-
                                            ${c_green},--.${c_black}/${c_green},-.${c_reset}
    ${c_blue}        ___     __   __   __   ___     ${c_green}/,-._.--~\'${c_reset}
    ${c_blue}  |\\ | |__  __ /  ` /  \\ |__) |__         ${c_yellow}}  {${c_reset}
    ${c_blue}  | \\| |       \\__, \\__/ |  \\ |___     ${c_green}\\`-._,-`-,${c_reset}
                                            ${c_green}`._,._,\'${c_reset}
    ${c_purple}  nf-core/cleansumstats v${workflow.manifest.version}${c_reset}
    -${c_dim}--------------------------------------------------${c_reset}-
    """.stripIndent()
}

def checkHostname(){
    def c_reset = params.monochrome_logs ? '' : "\033[0m"
    def c_white = params.monochrome_logs ? '' : "\033[0;37m"
    def c_red = params.monochrome_logs ? '' : "\033[1;91m"
    def c_yellow_bold = params.monochrome_logs ? '' : "\033[1;93m"
    if (params.hostnames) {
        def hostname = "hostname".execute().text.trim()
        params.hostnames.each { prof, hnames ->
            hnames.each { hname ->
                if (hostname.contains(hname) && !workflow.profile.contains(prof)) {
                    log.error "====================================================\n" +
                            "  ${c_red}WARNING!${c_reset} You are running with `-profile $workflow.profile`\n" +
                            "  but your machine hostname is ${c_white}'$hostname'${c_reset}\n" +
                            "  ${c_yellow_bold}It's highly recommended that you use `-profile $prof${c_reset}`\n" +
                            "============================================================"
                }
            }
        }
    }
}
